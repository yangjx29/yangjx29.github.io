<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Nowcoder Linux, JacksonYang的博客">
    <meta name="description" content="

linux高性能服务器编程查询接口的网址
入门
提问



gcc编译过程

汇编

-D 在编译时给程序指定一个宏


* 
gcc和g++的区别
都是GNU(组织) 的一个编译器
两者都可以编译c和c++程序
后缀.c的gcc把它当">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Nowcoder Linux | JacksonYang的博客</title>
    <link rel="icon" type="image/png" href="/medias/image.png">
    
    <style>
        body{
            background-image: url(/medias/banner/11.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/image.svg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JacksonYang的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/MyArxiv" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>定制Arxiv</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/image.svg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JacksonYang的博客</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/MyArxiv" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			定制Arxiv
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Nowcoder Linux</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Linux%E7%9B%B8%E5%85%B3/" class="post-category">
                                Linux相关
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-08-08
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    48.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    200 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <meta name="referrer" content="no-referrer"/>

<h1 id="linux高性能服务器编程"><a href="#linux高性能服务器编程" class="headerlink" title="linux高性能服务器编程"></a>linux高性能服务器编程</h1><p><a target="_blank" rel="noopener" href="https://www.chinastor.com/manuals/linuxfunctions/">查询接口的网址</a></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul>
<li>提问<ul>
<li><img src="https://img-blog.csdnimg.cn/2368c493d5e74a719a4c10a14f52bf28.png" alt="image-20230817214308019"></li>
</ul>
</li>
<li>gcc编译过程<ul>
<li><img src="https://img-blog.csdnimg.cn/48a013b0991344e0be2924ff7ba6033b.png" alt="image-20230818151825613"></li>
<li>汇编</li>
<li><img src="https://img-blog.csdnimg.cn/7504cc613bc74b0dab7a42223a869a8c.png" alt="image-20230818151858659"><ul>
<li>-D 在编译时给程序指定一个宏</li>
</ul>
</li>
<li><img src="https://img-blog.csdnimg.cn/a9e29a8997844f2a892fef94ac3b374d.png" alt="image-20230818154854334"><br>* </li>
<li>gcc和g++的区别<ul>
<li>都是GNU(组织) 的一个编译器</li>
<li>两者都可以编译c和c++程序<ul>
<li>后缀.c的gcc把它当做是c代码，而g++当成cpp代码</li>
<li>后缀.cpp两者都会认为是c++程序</li>
<li>编译阶段g++会调用gcc，因为gcc命令不能自动和c++程序使用的库连接<strong>，所以通常用g++来完成链接</strong>，所以之后统一用g++</li>
</ul>
</li>
<li><img src="https://img-blog.csdnimg.cn/783d0a64252142abb7ae4a35a1ffc804.png" alt="image-20230818153538141"></li>
<li><img src="https://img-blog.csdnimg.cn/8a71d5998d1e45019c99eba092fe7730.png" alt="image-20230818153815848"><ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h3><ul>
<li><p>库文件是计算机的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量</p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/4f41fa02dfc2422aa7f8275d9a117c1c.png" alt="image-20230818160105607"></p>
<ul>
<li>编写库文件和编写一般的程序区别不大，只是库不能单独运行</li>
</ul>
</li>
<li><p>制作静态库</p>
<ul>
<li>命名规则：<ul>
<li>linux：libxxx.a<ul>
<li>lib:前缀(固定)</li>
<li>xxx:库的名字，自己起</li>
<li>.a ：后缀(固定)</li>
</ul>
</li>
<li>windows：libxxx.lib</li>
</ul>
</li>
<li>步骤<ul>
<li>gcc获得.0文件</li>
<li>将其打包，使用ar工具</li>
</ul>
</li>
<li><img src="https://img-blog.csdnimg.cn/ad2c3e94d1414732890167a30317902b.png" alt="image-20230818160851521"></li>
</ul>
</li>
<li><p>制作过程</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/da40904485ea40939452334a712c1a92.png" alt="image-20230818161436745"></li>
<li>gcc -c 生成 .o文件</li>
</ul>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/769753cd552249569a8d1048f4d8ee18.png" alt="image-20230818161516481"></p>
<ul>
<li>使用 ar rcs命令生成静态库</li>
</ul>
</li>
<li><p><strong>静态库的使用</strong></p>
<ul>
<li>把库和库所依赖的头文件都要给使用者</li>
<li>注意gcc编译时找的是同级的目录，怎么解决<ul>
<li>使用 –I  <ul>
<li>-l 后跟要查找的目录</li>
</ul>
</li>
</ul>
</li>
<li>-l <ul>
<li>指定要使用哪个库</li>
</ul>
</li>
<li><img src="https://img-blog.csdnimg.cn/93e8e3996351462bb8a0dabe3fdf97e3.png" alt="image-20230818190830722"></li>
<li><img src="https://img-blog.csdnimg.cn/2dcc49a0e7284a43997c8223397a1cef.png" alt="image-20230818190916189"><ul>
<li>-L 查找静态库的位置</li>
</ul>
</li>
</ul>
</li>
<li><p>最终使用实例</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/97d729da4fd94b05808da64e14cf48dd.png" alt="image-20230818191405222"><ul>
<li><strong>-L 指定静态库路径</strong></li>
<li><strong>-l 指定静态库名称</strong></li>
<li>注意：静态库名称不需要前缀lib和后缀.a</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="动态库的制作和使用"><a href="#动态库的制作和使用" class="headerlink" title="动态库的制作和使用"></a>动态库的制作和使用</h3><ul>
<li>命名规则<ul>
<li>linux：libxxx.so<ul>
<li>前缀：lib (固定)</li>
<li>后缀：.so(固定)</li>
<li>在linux下是一个可执行文件</li>
</ul>
</li>
<li>windows：<strong>libxxx.dll</strong></li>
</ul>
</li>
<li>制作过程<ul>
<li>gcc 得到.o文件，得到和位置无关的代码</li>
<li>gcc -c -fpic  a.c  b.c</li>
<li>gcc得到动态库</li>
<li>gcc -shared a.o b.o -o libcalc.so</li>
</ul>
</li>
<li><img src="https://img-blog.csdnimg.cn/dc6239b4f2c340c2981a2470226e918c.png" alt="image-20230818193442741"><ul>
<li>加上参数-fpic得到与位置无关的路径</li>
</ul>
</li>
<li>使用示例<ul>
<li><img src="https://img-blog.csdnimg.cn/6ced9e02903d4971ba13ae40765bd3df.png" alt="image-20230818194524227"><ul>
<li>绿色文件代表可执行文件</li>
</ul>
</li>
<li><img src="https://img-blog.csdnimg.cn/e40712d5a4234aa6bb44f44c74b73565.png" alt="image-20230818194654659"></li>
<li><img src="https://img-blog.csdnimg.cn/f211ce19643c4168a31d02947b066854.png" alt="image-20230818194909297"><ul>
<li>注意，按静态库的方法编译出来，会报错。动态库找不到对应的文件</li>
</ul>
</li>
<li>动态库加载原理和解决方案<ul>
<li>静态库工作原理<ul>
<li>GCC进行链接时，会把静态库中代码打包到可执行程序中</li>
</ul>
</li>
<li>动态库：<ul>
<li>GCC进行链接时，<strong>动态库的代码不会被打包到可执行程序中</strong></li>
<li><strong>程序启动之后，动态库会被动加载到内存中</strong>，通过ldd(list dynamic dependencies)命令检查动态库依赖关系</li>
<li><img src="https://img-blog.csdnimg.cn/9ca17e023dc8455397956f0d516217b4.png" alt="image-20230818201935305"></li>
<li>以上是动态库如何载入内存中的先后顺序，在以上的路径之一中加入动态库的绝对路径就行</li>
<li>配置LD_LIBRARY_PATH中的动态库的绝对位置</li>
<li>终端级配置<ul>
<li>export LD_LIBRARY_PATH &#x3D; $LD_LIBRARY_PATH:动态库的绝对路径<ul>
<li><img src="https://img-blog.csdnimg.cn/6810417f80ca484e88ca69f66dc8a74d.png" alt="image-20230818203408344"></li>
</ul>
</li>
<li>配置完成之后使用ldd查找命令，libcalc.so 显示出正确的绝对路径 <ul>
<li><img src="https://img-blog.csdnimg.cn/8ebd5e2d65664df6af468bc4bb16aae9.png" alt="image-20230818203512098"></li>
<li>不再是not found</li>
</ul>
</li>
<li>export配置方式是终端中的配置，将终端关闭之后即消失</li>
</ul>
</li>
<li>用户级配置<ul>
<li>在  .bashrc文件中添加export LD_LIBRARY_PATH &#x3D; $LD_LIBRARY_PATH:动态库的绝对路径</li>
<li>. .bashrc命令使配置生效</li>
<li><img src="https://img-blog.csdnimg.cn/6be5ec4a72a8499dbf624e3293f29b28.png" alt="image-20230818204139005"></li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="静态库和动态库的总结和对比"><a href="#静态库和动态库的总结和对比" class="headerlink" title="静态库和动态库的总结和对比"></a>静态库和动态库的总结和对比</h3><ul>
<li><p>程序编译成可执行程序的过程</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/5891a4a5535c483fa14df3f3416f1b3a.png" alt="image-20230818211921410"><ul>
<li>静态库和动态库都是在链接阶段进行处理</li>
</ul>
</li>
</ul>
</li>
<li><p>静态库的制作过程</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/28ffe83491674dbcb5cff0f5d81f5edb.png" alt="image-20230818212303322"></li>
</ul>
</li>
<li><p>动态库的制作过程</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/1ee33f39dfb946c2a8ea9f71b20149e1.png" alt="image-20230818212422016"></li>
</ul>
</li>
<li><p>静态库的优缺点</p>
<ul>
<li>优点：<ul>
<li>被打包到应用程序中，加载速度快</li>
<li>发布程序无需提供静态库，移植方便</li>
</ul>
</li>
<li>缺点：<ul>
<li>消耗系统资源，浪费内存</li>
<li>更新、部署、发布麻烦</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/bf01ae717a1c4f81b117c3ad340db7cf.png" alt="image-20230818213423747"></p>
</li>
<li><p>动态库的优缺点</p>
<ul>
<li>优点：<ul>
<li>可以实现进程间的资源共享(共享库)</li>
<li>更新、部署、发布简单</li>
<li>可以控制何时加载动态库</li>
</ul>
</li>
<li>缺点：<ul>
<li>加载速度比静态库慢</li>
<li>发布程序时需要提供依赖的动态库</li>
</ul>
</li>
</ul>
<p> <img src="https://img-blog.csdnimg.cn/cec6bc8ba8bc4610b0a47a25f6bd33cb.png" alt="image-20230818213906998"></p>
</li>
</ul>
<h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后变异，哪些文件需要重新编译。</p>
</li>
<li><p>makefile文件就像一个shell脚本一样，也可以执行操作系统的命令</p>
</li>
<li><p>好处：</p>
<ul>
<li>自动化编译</li>
<li>一旦写好，只需要一个make命令，整个工程就可以完全自动编译，极大的提高了软件开发的效率</li>
<li></li>
</ul>
</li>
<li><p>规则</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/f4b076bd842a46b1b52aa535c0ec38c3.png" alt="image-20230820115900022"><ul>
<li>makefile中可以有其他的规则，其他规则都是为上面的规则服务的</li>
</ul>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/20af54ef107340a8a8a34165622e4c9d.png" alt="image-20230820120601055"></p>
</li>
<li><p>工作原理</p>
<ul>
<li><p>命令在执行前，需要先检查规则中的<strong>依赖是否存在</strong></p>
<ul>
<li>如果存在执行命令</li>
<li>如果不存在，向下检查其他的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了则执行该规则中的命令</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/7c21209369924247819bb5aaa01e21d5.png" alt="image-20230820153023845"></p>
<ul>
<li>注意：下面的规则都是默认为第一条规则服务，若第一条规则中没有出现，那么有些命令不会执行</li>
</ul>
</li>
<li><p>检查更新，在执行规则中的命令时，会比较目标和依赖文件的时间</p>
<ul>
<li>如果依赖的时间比目标时间晚，则需要重新生成目标</li>
<li>如果依赖的时间比目标时间早，目标不需要更新，对应规则中的命令不需要被执行</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/18d65d862e2d43a2b53014d052bf110c.png" alt="image-20230820153800782"></p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/985e8677bdca4b19a341ddaf32671b7d.png" alt="image-20230820154132957"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p><img src="https://img-blog.csdnimg.cn/59ae05dfd9b2401eba029d37d2220554.png" alt="image-20230820154434059"></p>
</li>
<li><p>自定义变量</p>
<ul>
<li><p>var &#x3D; hello </p>
</li>
<li><p>预定义变量</p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/c94d6a23c86c41f0a4426bb003afa427.png" alt="image-20230820154657333"></p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/a7df87b47521481e972b6f704b84878c.png" alt="image-20230820155235868"></p>
<ul>
<li>简化版本如上图</li>
</ul>
</li>
<li><p><strong>模式匹配法</strong></p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/9eb2b5b204a04e509fe177f4044af894.png" alt="image-20230820155306513"></li>
<li><img src="https://img-blog.csdnimg.cn/c81e546c5481460a860964e40ba5dcf1.png" alt="image-20230820162653437"></li>
</ul>
</li>
<li><p>函数**$(wildcard PATTERN …)**</p>
<ul>
<li><p>$(wildcard PATTERN …)</p>
<ul>
<li>功能：获取指定目录下指定类型的文件列表</li>
<li>参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔</li>
<li>返回：得到的若干个文件的文件列表，文件名之间使用空格间隔</li>
<li>示例：<ul>
<li>$(wildcard <em>.c .&#x2F;sub&#x2F;</em>.c)</li>
<li>返回值格式:a.c b.c c.c d.c e.c f.c</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/ca2a61d8d06643498e25816ac78ddd6a.png" alt="image-20230820182626111"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>$(patsubst <pattern>, <replacement>,<text>)</p>
<ul>
<li>功能：查找<text>中的单词(单词以”空格”、”Tab”或”回车””换行”分割)是否符合<pattern>，如果匹配的话，则以<replacement>替换</li>
<li><pattern>可以包括通配符%，表示任意长度的字符串。如果<replacement>中也包含%，那么<replacement>中的这个%将是<pattern>中的那个%所代表的字串</li>
<li>返回：函数返回被替代过后的字符串</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c8ad25a3665346bf8c02dca3dc8c09fc.png" alt="image-20230820183919220"></p>
<ul>
<li>示例</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/800a34c4dc874243aaadb6b088564174.png" alt="image-20230821143251056"></p>
<ul>
<li>注意！patsubst不能有空格，否则会将.c文件一起删除!!!</li>
</ul>
</li>
</ul>
<h3 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h3><ul>
<li><p>GDB是由GUN提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类U你下系统中的标准开发环境</p>
</li>
<li><p>完成的四大功能</p>
<ul>
<li>启动程序，可以按照自定义的要求随心所欲的运行程序</li>
<li>可以让调试的程序在所指定的调置的断点处停住(断点可以是条件表达式)</li>
<li>当程序被停住时，可以检查此时程序中所发生的事</li>
<li>可以改变程序，将一个bug产生的影响修正从而测试其他bug</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/db3d77156ab943238207efbdb6aaae37.png" alt="image-20230821150714851"></p>
</li>
<li><p>调试准备</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/c974b498bbd548f99cac61de50b34c68.png" alt="image-20230821151302221"></li>
</ul>
</li>
<li><p>GDB的命令</p>
<ul>
<li>基本操作<ul>
<li><img src="https://img-blog.csdnimg.cn/27f64dd91d1b493f99cf3ef8fd842fdc.png" alt="image-20230821151316149"><ul>
<li>使用GDB list命令查看</li>
</ul>
</li>
</ul>
</li>
<li>断点操作<ul>
<li><img src="https://img-blog.csdnimg.cn/b76fbb660299449ca6f13a43ae0e3a9b.png" alt="image-20230821160926177"><ul>
<li><img src="https://img-blog.csdnimg.cn/806abfa2412544359d89357d26a4bcce.png" alt="image-20230821161638258"><ul>
<li>删除断点</li>
</ul>
</li>
<li>设置断点不可用<ul>
<li><img src="https://img-blog.csdnimg.cn/8ba1cf2ae2364422ab58b263d4515c78.png" alt="image-20230821162002872"></li>
<li>disable + number</li>
</ul>
</li>
<li>设置条件断点<ul>
<li><img src="https://img-blog.csdnimg.cn/6163142d6836452592399d26ac54f6ba.png" alt="image-20230821162210161"></li>
</ul>
</li>
</ul>
</li>
<li>启动GDB程序、调试命令<ul>
<li><img src="https://img-blog.csdnimg.cn/59684d6cde874d8ba746be168d00810d.png" alt="image-20230821185038336"><ul>
<li>注意start和run的区别</li>
<li>想要跳过循环，必须将程序内部的断点先删除掉，然后再循环判断起始跳过</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="标准c库io函数和Linux系统io函数对比"><a href="#标准c库io函数和Linux系统io函数对比" class="headerlink" title="标准c库io函数和Linux系统io函数对比"></a>标准c库io函数和Linux系统io函数对比</h3><ul>
<li><p>从内存的角度考虑IO</p>
</li>
<li><p>两者是调用和被调用的关系</p>
<ul>
<li><p>c标准库调用内核函数</p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/d34ddcb7a4f24e19806a35f5a06028f8.png" alt="image-20230821195822872"></p>
</li>
<li><p>文件描述符：指定打开的文件，定位文件</p>
</li>
<li><p>文件读写指针：读取和写数据，内部维护两个指针</p>
</li>
<li><p>I&#x2F;O缓冲区：提高执行的效率。当缓冲区慢了，系统调用读写程序</p>
<ul>
<li><p>什么时候将缓冲区内容写到瓷盘</p>
<p><img src="https://img-blog.csdnimg.cn/3ad0f81f77c2473b8e212af394c2732b.png" alt="image-20230821195430624"></p>
<ul>
<li><strong>缓冲区默认字节8192B</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><ul>
<li>虚拟地址空间<strong>是不存在的</strong></li>
<li><strong>虚拟内存会被mmu映射到实际的内存中</strong></li>
<li>分为<strong>用户区和内核区</strong><ul>
<li><img src="https://img-blog.csdnimg.cn/2709524dd0e44db2b8c6831452d1aaad.png" alt="image-20230824203318343"><ul>
<li>NULL和nullptr 都在受保护的地址中</li>
<li>堆空间要比栈空间大。<strong>堆空间从下往上，栈空间从上往下</strong></li>
<li>系统调用：调用Linux系统中的API<ul>
<li>通过系统调用对内核进行操作</li>
<li>内核区：<ul>
<li>内存管理</li>
<li>进程管理</li>
<li>设备驱动管理</li>
<li>文件系统</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li>文件描述符在进程的内核区<ul>
<li>内核区中有PCB(一个复杂的结构体)，由进程控制块管理进程</li>
<li>PCB中有一个数组，叫做<strong>文件描述符表</strong>，默认大小是1024.最多同时打开1024个文件<ul>
<li>里面可以存储多个文件描述符</li>
<li>可以同时打开多个文件,一个文件对应一个文件描述符</li>
</ul>
</li>
<li>文件描述符表<ul>
<li><img src="https://img-blog.csdnimg.cn/4de4af614b674ed0b4d8871c35b3b72d.png" alt="image-20230824205128646"></li>
<li>前三个默认为打开状态，对应于<strong>当前终端</strong></li>
<li><strong>一个文件可以同时被打开多次，对应多个文件描述符，每个文件描述符是不同的</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><ul>
<li><p>perror的具体用法</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/766281dee4c4480093442a11d05b0b7b.png" alt="image-20230824212328776"></li>
</ul>
</li>
<li><p>open总结</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//打开一个已经存在的文件</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        -pathname：要打开的文件路径 </span></span><br><span class="line"><span class="comment">        -flags  must include one of the following </span></span><br><span class="line"><span class="comment">            access modes: O_RDONLY, O_WRONLY, or O_RDWR 这三个操作是互斥的</span></span><br><span class="line"><span class="comment">    返回值：</span></span><br><span class="line"><span class="comment">        -是文件描述符,若定位失败返回 -1 </span></span><br><span class="line"><span class="comment">        errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号</span></span><br><span class="line"><span class="comment">        perror：</span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">作用：打印error对应的错误描述</span></span><br><span class="line"><span class="comment">    参数s：用户描述，比如hello，最终输出的内容是hello:xxx(实际的错误描述)</span></span><br><span class="line"><span class="comment">void perror(const char *s);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//创建一个文件</span></span><br><span class="line"><span class="comment">int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建新文件"><a href="#创建新文件" class="headerlink" title="创建新文件"></a>创建新文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    //创建一个文件</span></span><br><span class="line"><span class="comment">    int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -pathname：要创建的文件的路径</span></span><br><span class="line"><span class="comment">        -flags：对文件的操作权限和其他的设置</span></span><br><span class="line"><span class="comment">                是一个int类型的数据，占4个字节，32位，每一位就是一个标志位</span></span><br><span class="line"><span class="comment">        必选项：O_RDONLY, O_WRONLY, or O_RDWR 三选一</span></span><br><span class="line"><span class="comment">        可选项：O_CREATE 文件不存在，创建新文件</span></span><br><span class="line"><span class="comment">        -mode：八进制的数，表示用户创建出的新的操作权限</span></span><br><span class="line"><span class="comment">            最终的权限是 mode &amp; ~umask  umask = 0022 ~umask = 0755</span></span><br><span class="line"><span class="comment">            0777 -&gt; 111111111</span></span><br><span class="line"><span class="comment">            0755 -&gt; 111101101 两者相与  umask作用是抹去某些权限</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;create.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="read、write函数"><a href="#read、write函数" class="headerlink" title="read、write函数"></a>read、write函数</h3><ul>
<li><p>系统中的IO函数</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/6796b2ec4b6e4191a76b52d151585c2e.png" alt="image-20230825113414291"></li>
</ul>
</li>
<li><p>具体使用</p>
<ul>
<li><pre><code class="cpp">/*
    #include &lt;unistd.h&gt;
    参数
        - fd 文件描述符 通过文件描述符操作某一个文件
        - buf 需要读取数据存放的地方，一般是数组的地址 ，是缓冲区(传出参数)
        - count 指定的数组的大小

    返回值
        - 成功:
            &gt;0 : 返回实际的读取到的字节数
            =0 : 文件已经读取完了
        - 失败
            -1 : 文件读取失败
    ssize_t read(int fd, void buf[.count], size_t count);


    #include &lt;unistd.h&gt;
    参数
        - fd 文件描述符 通过文件描述符操作某一个文件，一般通过open得到
        - buf 写入数据的地方，一般是数组的地址 ，是缓冲区(传出参数)
        - count 要写的数据的的实际的大小
    返回值
        - 成功:
            &gt;0 : 返回实际的写入的字节数
            =0 : 没有任何内容写入
        - 失败
            -1 : 文件写入失败
    ssize_t write(int fd, const void buf[.count], size_t count);

*/

#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main() &#123;
    // 通过open打开文件
    int srcfd = open(&quot;english.txt&quot;, O_RDONLY);
    if (srcfd == -1) &#123;
        perror(&quot;open&quot;);
        return -1;
    &#125;

    // 创建一个新的文件(拷贝文件)
    int destfd = open(&quot;cpy.txt&quot;, O_WRONLY | O_CREAT, 0664);
    if (destfd == -1) &#123;
        perror(&quot;copy&quot;);
        return -1;
    &#125;
    // 频繁的读写数据
    char buf[1024] = &#123;0&#125;;
    int len = 0;
    while ((len = read(srcfd, buf, sizeof(buf))) &gt; 0) &#123;
        write(destfd, buf, len);
    &#125;
    // 关闭文件
    close(destfd);
    close(srcfd);

    return 0;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### lseek函数</span><br><span class="line"></span><br><span class="line">~~~c</span><br><span class="line">  /*</span><br><span class="line">      #include &lt;unistd.h&gt;</span><br><span class="line">      参数</span><br><span class="line">          - fd 文件描述符</span><br><span class="line">          - offset 偏移量</span><br><span class="line">          - whence  </span><br><span class="line">         SEEK_SET</span><br><span class="line">                The file offset is set to offset bytes.</span><br><span class="line">                设置文件指针的偏移量</span><br><span class="line">  </span><br><span class="line">         SEEK_CUR</span><br><span class="line">                The file offset is set to its current location plus offset bytes.</span><br><span class="line">                设置偏移量：当前位置 + 第二个参数offset的值</span><br><span class="line">  </span><br><span class="line">         SEEK_END</span><br><span class="line">                The file offset is set to the size of the file plus offset bytes.</span><br><span class="line">                设置偏移量：文件大小 + 第二个offset的值 </span><br><span class="line">      返回值：返回文件指针的位置  </span><br><span class="line">      off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">      函数的作用</span><br><span class="line">          1.移动文件指针到头文件</span><br><span class="line">              lseek(fd,0,SEEK_SET);</span><br><span class="line">          2.获取当前文件指针的位置</span><br><span class="line">              lseek(fd,0,SEEK_CUR);</span><br><span class="line">          3.获取文件长度</span><br><span class="line">              lseek(fd,0,SEEK_END);</span><br><span class="line">          4.拓展文件的长度，当前文件10b，增加100字节</span><br><span class="line">              lseek(fd,100,SEEK_END);</span><br><span class="line">          </span><br><span class="line">  */</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  #include &lt;unistd.h&gt;</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">  #include &lt;sys/stat.h&gt;</span><br><span class="line">  #include &lt;fcntl.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">      int fd = open(&quot;hello.txt&quot; , O_RDWR);</span><br><span class="line">      if(fd == -1)&#123;</span><br><span class="line">          perror(&quot;open&quot;);</span><br><span class="line">          return -1;</span><br><span class="line">      &#125;</span><br><span class="line">      int ret = lseek(fd,100,SEEK_END);</span><br><span class="line">      if(ret == -1)&#123;</span><br><span class="line">          perror(&quot;lseek&quot;);</span><br><span class="line">          return -1;</span><br><span class="line">      &#125;</span><br><span class="line">      //写入空数据</span><br><span class="line">      write(fd , &quot; &quot; , 1);</span><br><span class="line">      close(fd);</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>用途</p>
<ul>
<li>拓展文件，提前将文件大小拓展出来，占用好。避免内存不够的情景</li>
<li>注意文件拓展要进行一次写入之后，拓展的大小才能生效</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="stat，lstat函数"><a href="#stat，lstat函数" class="headerlink" title="stat，lstat函数"></a>stat，lstat函数</h3><ul>
<li><p>stat结构体参数</p>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/83a576eb03a94c849cb90e5472a7eb18.png" alt="image-20230825150650081"></p>
</li>
<li><p>st_mode变量</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/f6b2468e3899420daf610075c8595810.png" alt="image-20230825150852029"><ul>
<li>如何查看权限<ul>
<li>进行<strong>与</strong>操作</li>
</ul>
</li>
<li>判断文件类型<ul>
<li>与掩码进行<strong>与</strong>操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - pathname 操作文件的路径</span></span><br><span class="line"><span class="comment">        - statbuf 结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功 0</span></span><br><span class="line"><span class="comment">        失败 -1 设置errno</span></span><br><span class="line"><span class="comment">       int stat(const char *restrict pathname,</span></span><br><span class="line"><span class="comment">                struct stat *restrict statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">       int lstat(const char *restrict pathname,</span></span><br><span class="line"><span class="comment">                struct stat *restrict statbuf);</span></span><br><span class="line"><span class="comment">        与上一个函数的区别：该函数获取的是软连接文件的信息，而上一个函数获取的是原函数的信息</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;a.txt&quot;</span> , &amp;statbuf);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %ld\n &quot;</span>,statbuf.st_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="模拟实现ls-l"><a href="#模拟实现ls-l" class="headerlink" title="模拟实现ls  -l"></a>模拟实现ls  -l</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现ls -l 指令 -rwxrwxrwx 1 yjx yjx 11 Aug 25 15:17 a.txt*</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 判断输入的参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s filename\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过stat函数获取用户传入的文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = stat(argv[<span class="number">1</span>], &amp;st);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取文件类型和文件权限</span></span><br><span class="line">    <span class="type">char</span> perms[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 保存文件类型和文件权限</span></span><br><span class="line">    <span class="keyword">switch</span> (st.st_mode &amp; __S_IFMT) &#123;</span><br><span class="line">    <span class="keyword">case</span> __S_IFLNK:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFDIR:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFREG:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFBLK:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFCHR:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFSOCK:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFIFO:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    perms[<span class="number">1</span>] = (st.st_mode &amp; S_IRUSR) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>] = (st.st_mode &amp; S_IWUSR) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>] = (st.st_mode &amp; S_IXUSR) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件的所在组</span></span><br><span class="line">    perms[<span class="number">4</span>] = (st.st_mode &amp; S_IRGRP) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>] = (st.st_mode &amp; S_IWGRP) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>] = (st.st_mode &amp; S_IXGRP) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他人</span></span><br><span class="line">    perms[<span class="number">7</span>] = (st.st_mode &amp; S_IROTH) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>] = (st.st_mode &amp; S_IWOTH) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>] = (st.st_mode &amp; S_IXOTH) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取硬链接数</span></span><br><span class="line">    <span class="type">int</span> linkNum = st.st_nlink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    <span class="type">char</span>* fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所在组</span></span><br><span class="line">    <span class="type">char</span>* fileGrp = getgrgid(st.st_gid)-&gt;gr_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> fileSize = st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取修改时间</span></span><br><span class="line">    <span class="type">char</span>* time = ctime(&amp;st.st_mtime);</span><br><span class="line">    <span class="type">char</span> mtime[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(mtime , time , <span class="built_in">strlen</span>(time) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s %d %s %s %ld %s %s&quot;</span>, perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="文件属性操作函数"><a href="#文件属性操作函数" class="headerlink" title="文件属性操作函数"></a>文件属性操作函数</h3><ul>
<li><p><img src="https://img-blog.csdnimg.cn/5407fa5951f848e698096b1a85759738.png" alt="image-20230825192118122"></p>
</li>
<li><p>access</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - pathname 判断的文件路径</span></span><br><span class="line"><span class="comment">        - mode </span></span><br><span class="line"><span class="comment">            R_OK: 判断是否有读权限</span></span><br><span class="line"><span class="comment">            W_OK: 判断是否有写权限</span></span><br><span class="line"><span class="comment">            X_OK: 判断是否有执行权限</span></span><br><span class="line"><span class="comment">            F_OK: 判断文件是否有存在</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">        成功 0</span></span><br><span class="line"><span class="comment">        失败 -1</span></span><br><span class="line"><span class="comment">    int access(const char *pathname, int mode);</span></span><br><span class="line"><span class="comment">    作用:判断某个文件是否有某个权限，或者判断文件是否存在</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;a.txt&quot;</span> , F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;access&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件存在\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>chmod</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    修改文件的权限</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - pathname： 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">        - mode： 需要修改的权限值，八进制的数</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回0 </span></span><br><span class="line"><span class="comment">        失败返回-1</span></span><br><span class="line"><span class="comment">    int chmod(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = chmod(<span class="string">&quot;a.txt&quot;</span>,<span class="number">0775</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;修改成功\n&quot;</span>);\</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>truncate</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    缩减或者扩展文件的尺寸至指定的大小</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - path 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">        - length 需要最终文件变成的大小</span></span><br><span class="line"><span class="comment">    int truncate(const char *path, off_t length);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = truncate(<span class="string">&quot;b.txt&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;truncate&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h3><ul>
<li><p><img src="https://img-blog.csdnimg.cn/2f050276c7bc4787a806358610a692ee.png" alt="image-20230825200219228"></p>
</li>
<li><p>mkdir</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int mkdir(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        作用：创建一个目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            pathname: 创建的目录的路径</span></span><br><span class="line"><span class="comment">            mode: 权限，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = mkdir(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>rename</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int rename(const char *oldpath, const char *newpath);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = rename(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;rename&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>chdir、getcwd</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int chdir(const char *path);</span></span><br><span class="line"><span class="comment">        作用：修改进程的工作目录</span></span><br><span class="line"><span class="comment">            比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            path : 需要修改的工作目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    char *getcwd(char *buf, size_t size);</span></span><br><span class="line"><span class="comment">        作用：获取当前工作目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - buf : 存储的路径，指向的是一个数组（传出参数）</span></span><br><span class="line"><span class="comment">            - size: 数组的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            返回的指向的一块内存，这个数据就是第一个参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改工作目录</span></span><br><span class="line">    <span class="type">int</span> ret = chdir(<span class="string">&quot;/home/nowcoder/Linux/lesson13&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;chdir.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf1, <span class="keyword">sizeof</span>(buf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h3><ul>
<li><p><img src="https://img-blog.csdnimg.cn/2551713f1e624259aa26261c87575577.png" alt="image-20230826142644407"></p>
</li>
<li><p>dirent结构体和d_type</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/8cf109f2c3fb469bbddb89400a0a5c85.png" alt="image-20230826144649236"><ul>
<li>d_reclen：文件的实际长度</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 打开一个目录</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    DIR *opendir(const char *name);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - name: 需要打开的目录的名称</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            DIR * 类型， 理解为目录流</span></span><br><span class="line"><span class="comment">            错误返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 读取目录中的数据</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    struct dirent *readdir(DIR *dirp);</span></span><br><span class="line"><span class="comment">        - 参数：dirp是opendir返回的结果</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            struct dirent，代表读取到的文件的信息</span></span><br><span class="line"><span class="comment">            读取到了末尾或者失败了，返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 关闭目录</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int closedir(DIR *dirp);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取某个目录下普通文件的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s path\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = getFileNum(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;普通文件的个数为: %d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于获取目录下所有普通文件的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFileNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.打开目录</span></span><br><span class="line">    DIR* dir = opendir(path);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.读取文件</span></span><br><span class="line">    <span class="comment">// 记录普通话文件的个数</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">while</span> ((ptr = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取名称</span></span><br><span class="line">        <span class="type">char</span>* dname = ptr-&gt;d_name;</span><br><span class="line">        <span class="comment">// 忽略掉.和..</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dname, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dname, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是普通文件还是目录</span></span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">            <span class="comment">// 目录 需要继续读取这个目录</span></span><br><span class="line">            <span class="type">char</span> newpath[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(newpath, <span class="string">&quot;%s/%s&quot;</span>, path, dname);</span><br><span class="line">            cnt += getFileNum(newpath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="comment">// 普通文件</span></span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="dup、dup2函数"><a href="#dup、dup2函数" class="headerlink" title="dup、dup2函数"></a>dup、dup2函数</h3><ul>
<li><p><img src="https://img-blog.csdnimg.cn/e423df16519b411d95a9efd9b014c042.png" alt="image-20230826152512290"></p>
<ul>
<li>dup复制文件描述符</li>
<li>dup2重定向文件描述符</li>
</ul>
</li>
<li><p>dup</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    作用 复制一个新的文件描述符 指向同一个文件</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        oldfd: 原文件描述符</span></span><br><span class="line"><span class="comment">    int dup(int oldfd);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="type">int</span> fd1 = dup(fd);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d , fd1: %d\n&quot;</span>, fd, fd1);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret = write(fd1, str ,<span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>dup2</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    作用: 重定向文件描述符</span></span><br><span class="line"><span class="comment">    oldfd 指向 a.txt , newfd 指向 b.txt，调用函数成功后newfd 和b.txt做close，newfd指向了a.txt</span></span><br><span class="line"><span class="comment">    oldfd必须是一个有效的文件描述符，两者相同相当于什么都没做</span></span><br><span class="line"><span class="comment">    int dup2(int oldfd, int newfd);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span> , O_RDWR | O_CREAT , <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span> , O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d , fd1: %d\n&quot;</span>,fd,fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd2 = dup2(fd,fd1);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">//现在通过fd1去写数据，实际操作的是1.txt,而不是2.txt</span></span><br><span class="line">    <span class="type">int</span> ret = write(fd1,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d , fd1: %d , fd2: %d\n&quot;</span>,fd,fd1,fd2);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><ul>
<li><p><img src="https://img-blog.csdnimg.cn/72a7cb8ba3434353ac5c94dc6a7a009b.png" alt="image-20230826161549697"></p>
<ul>
<li>掌握如上两大功能</li>
<li><img src="https://img-blog.csdnimg.cn/06b0570ecd934eaf8db0e419e291c7fa.png" alt="image-20230829201827539"></li>
<li></li>
</ul>
</li>
</ul>
<h2 id="多进程开发"><a href="#多进程开发" class="headerlink" title="多进程开发"></a>多进程开发</h2><h3 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h3><ul>
<li>什么是程序<ul>
<li><img src="https://img-blog.csdnimg.cn/8f346498e1584a9f85727636084c122b.png" alt="image-20230827143121674"><ul>
<li>程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程</li>
</ul>
</li>
</ul>
</li>
<li>什么是进程<ul>
<li><img src="https://img-blog.csdnimg.cn/305ac02714e341968df60a70e87dba0f.png" alt="image-20230827143520324"><ul>
<li>进程是正在运行的程序的实例</li>
</ul>
</li>
</ul>
</li>
<li>单道、多道程序<ul>
<li><img src="https://img-blog.csdnimg.cn/eba5e8038dc0447cb3e8eb02e62c2b9e.png" alt="image-20230827143957209"><ul>
<li>从微观上看，任意时刻CPU上运行的程序只有一个</li>
</ul>
</li>
</ul>
</li>
<li>时间片<ul>
<li><img src="https://img-blog.csdnimg.cn/3b7025bbc4734bed88f5c438dc8f4efa.png" alt="image-20230827144228372"><ul>
<li>将时间切片，操作系统分配给每个正在运行的进程围观上的一段CPU事件</li>
<li>时间片通常非常短，用户不会感觉到</li>
</ul>
</li>
</ul>
</li>
<li>并行和并发<ul>
<li><img src="https://img-blog.csdnimg.cn/660733078f6246ac8f12eee4c32792b1.png" alt="image-20230827145200725"><ul>
<li>并行是同一时刻有多条指令在多个处理器上同时执行</li>
<li>并发是同一时刻只有一条指令执行</li>
</ul>
</li>
</ul>
</li>
<li>进程控制块PCB<ul>
<li><img src="https://img-blog.csdnimg.cn/17243162eb7148cdbd3a6c77fd986207.png" alt="image-20230827145429923"><ul>
<li>维护进程相关信息。</li>
<li>Linux内核的进程控制块是 tast_struct结构体</li>
<li>PCB中还有<ul>
<li><img src="https://img-blog.csdnimg.cn/fc57d4ab2d2f478fb91bfb856a1ca0a9.png" alt="image-20230827145629299"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3><ul>
<li>进程的基本三个状态<ul>
<li><img src="https://img-blog.csdnimg.cn/1d58ef65ce27473481e0bc04fd3a1b7f.png" alt="image-20230827145913902"></li>
<li>五态模型<ul>
<li><img src="https://img-blog.csdnimg.cn/4738d8e4e43540e29c219ecc7845a12f.png" alt="image-20230827151855151"></li>
</ul>
</li>
</ul>
</li>
<li>进程相关的命令<ul>
<li><img src="https://img-blog.csdnimg.cn/4db68e22dfd147e09d6adc8e2edf4404.png" alt="image-20230827152042220"></li>
<li>STAT参数意义：<ul>
<li><img src="https://img-blog.csdnimg.cn/d8c44f5092e84c8bbfe2cdbdd8016c29.png" alt="image-20230827152358884"></li>
</ul>
</li>
<li>查看父进程id 用ps ajx</li>
</ul>
</li>
<li>显示进程动态信息<ul>
<li><img src="https://img-blog.csdnimg.cn/6850b69d8c6e493dbb0f3a22e91a2e0f.png" alt="image-20230827152807943"></li>
</ul>
</li>
<li>杀死进程<ul>
<li><img src="https://img-blog.csdnimg.cn/fdd269e74b114b29b7aa0f27308b5eec.png" alt="image-20230827153125362"></li>
</ul>
</li>
<li>进程号和相关函数<ul>
<li><img src="https://img-blog.csdnimg.cn/349ae89cdc7847e781b5c5ba69ba8775.png" alt="image-20230827153334029"><ul>
<li>进程号是唯一的，但是可以重复使用</li>
<li>任何进程都有一个父进程(除了init进程)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><ul>
<li><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成树结构模型</p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/72272e2a79d848d399618b0774fc02d1.png" alt="image-20230827160007365"></p>
</li>
<li><p>fork()函数</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    作用: 用于创建子进程</span></span><br><span class="line"><span class="comment">    返回值: fork的返回值会返回两次:一次是在父进程中，一次是在子进程中</span></span><br><span class="line"><span class="comment">        在父进程中返回创建的子进程的ID</span></span><br><span class="line"><span class="comment">        在子进程中返回0</span></span><br><span class="line"><span class="comment">        如何父进程和子进程，通过fork的值返回</span></span><br><span class="line"><span class="comment">        在父进程中返回-1表示创建子进程失败，冰鞋设置errno</span></span><br><span class="line"><span class="comment">    什么时候会创建失败呢？</span></span><br><span class="line"><span class="comment">        1.当前系统的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN</span></span><br><span class="line"><span class="comment">        2.系统内存不足时，这时errno的值被设置为ENOMEM</span></span><br><span class="line"><span class="comment">    pid_t fork(void);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid : %d\n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// 当前是父进程,返回的是创建的子进程的进程号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process , pid : %d , ppid: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process , pid : %d , ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果如图<img src="https://img-blog.csdnimg.cn/09fe3944cd904a8f987e73f681f7d9cb.png" alt="image-20230827163950099"><ul>
<li><strong>子父进程交替运行(时间片)</strong></li>
</ul>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    作用: 用于创建子进程</span></span><br><span class="line"><span class="comment">    返回值: fork的返回值会返回两次:一次是在父进程中，一次是在子进程中</span></span><br><span class="line"><span class="comment">        在父进程中返回创建的子进程的ID</span></span><br><span class="line"><span class="comment">        在子进程中返回0</span></span><br><span class="line"><span class="comment">        如何父进程和子进程，通过fork的值返回</span></span><br><span class="line"><span class="comment">        在父进程中返回-1表示创建子进程失败，冰鞋设置errno</span></span><br><span class="line"><span class="comment">    什么时候会创建失败呢？</span></span><br><span class="line"><span class="comment">        1.当前系统的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN</span></span><br><span class="line"><span class="comment">        2.系统内存不足时，这时errno的值被设置为ENOMEM</span></span><br><span class="line"><span class="comment">    pid_t fork(void);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid : %d\n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// 当前是父进程,返回的是创建的子进程的进程号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process , pid : %d , ppid: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process , pid : %d , ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="父子进程虚拟地址空间情况"><a href="#父子进程虚拟地址空间情况" class="headerlink" title="父子进程虚拟地址空间情况"></a>父子进程虚拟地址空间情况</h4><ul>
<li><p>父子进程执行代码情况</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/915e7995abed4428808757144ba1c407.png" alt="image-20230827201254167"></li>
</ul>
</li>
<li><p>父子进程虚拟地址空间</p>
<ul>
<li>调用fork()函数相当于调用新的地址空间</li>
<li>子进程的用户区数据和父进程一样(克隆过来的)</li>
<li>内核区也会拷贝过来，但是pid不同。</li>
<li>fork()函数在父进程中执行，返回值pid是局部变量，在<strong>栈空间</strong>中。子进程不回执行fork()函数</li>
<li>两者的内存空间内容相同，但是是不同的地址</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/b7f57d47999144709f0863bbd4bef5bb.png" alt="image-20230827201908769"></p>
</li>
</ul>
<blockquote>
<p> Linux的fork函数是通过写时拷贝实现</p>
<p> 写时拷贝是一种可以推迟甚至避免拷贝数据的技术</p>
<p> 内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间</p>
<p> 只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自的地址空间</p>
</blockquote>
<ul>
<li>也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享</li>
<li><strong>注意！fork()之后是文件共享</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>父子进程之间的关系</p>
<ul>
<li>区别</li>
</ul>
<blockquote>
<p>1.fork()函数返回值不同</p>
<ul>
<li><p>父进程中： &gt; 0 返回的是子进程的id</p>
</li>
<li><p>子进程中: &#x3D;&#x3D; 0</p>
</li>
</ul>
<p>2.PCB中的一些数据不同</p>
<ul>
<li><p>当前进程的pid</p>
</li>
<li><p>当前进程的ppid</p>
</li>
<li><p>信号集</p>
</li>
</ul>
</blockquote>
<ul>
<li>共同点</li>
</ul>
<blockquote>
<p>某些状态下: 子进程刚被创建出来,还没有执行任何写数据的操作</p>
<pre><code>- 用户区的数据是一样的
-  文件描述符表
</code></pre>
</blockquote>
</li>
<li><p>父子进程对变量是不是共享的？</p>
<blockquote>
<p>刚开始的时候是一样的，是共享的。如果修改了数据，就不再共享</p>
<p><strong>读时共享，写时拷贝。</strong></p>
</blockquote>
</li>
</ul>
<h3 id="GBD多进程调试"><a href="#GBD多进程调试" class="headerlink" title="GBD多进程调试"></a>GBD多进程调试</h3><ul>
<li><img src="https://img-blog.csdnimg.cn/398f1ed1ca204b1d86e6d3d54fb4b090.png" alt="image-20230827211500922"><ul>
<li>使用 set follow-fork-mode 设置默认调试</li>
<li>set detach-on-fork设置调试模式</li>
<li>inferior id 切换调试的进程</li>
<li>datach inferiors id使进程脱离GDB调试</li>
</ul>
</li>
</ul>
<h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><ul>
<li><p>c语言中没有函数重载。一些列功能相同或相似的函数称为函数族</p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/1c23c7737fe44f5292971f56c6c575d6.png" alt="image-20230828092512320"></p>
<ul>
<li>需要传递文件名来找到可执行文件。在调用进程内部执行一个可执行文件<ul>
<li><strong>一般先用进程fork出子进程，在子进程中执行exec函数替代进程</strong></li>
</ul>
</li>
<li>调用成功不返回，失败返回-1</li>
</ul>
</li>
<li><p>图解，当执行exec函数之后</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/10a87ab8768e47669682239ff11b1aa3.png" alt="image-20230828093025909"><ul>
<li>两者已经交换了，但是id没变</li>
<li>躯壳没变，内部变了</li>
</ul>
</li>
</ul>
</li>
<li><p>exec函数族</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/1b90b46c99c0465aaed13298212ff0f2.png" alt="image-20230828093117034"><ul>
<li>前6个函数是标准c库中的函数，execvve()是Linux中的系统API</li>
</ul>
</li>
<li>前两个用的最多</li>
</ul>
</li>
<li><p>execl()函数</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/aa5f2841208c430fb50607f78ef42d1e.png" alt="image-20230828095153161"></li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    extern char **environ;</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">    - path: 需要指定的执行的文件的路径或者名称 推荐使用绝对路径</span></span><br><span class="line"><span class="comment">    - arg: 执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">        第一个参数一般没有什么作用，为了方便，一般写执行程序的名称</span></span><br><span class="line"><span class="comment">        从第二个参数开始往后，就是程序执行所需要的参数列表</span></span><br><span class="line"><span class="comment">        参数最后需要以NULL结束(哨兵)</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功不返回(因为调用成功之后用户区已经交换，收取返回值也没有意义了)</span></span><br><span class="line"><span class="comment">        只有调用失败才会返回-1并且设置errno</span></span><br><span class="line"><span class="comment">    int execl(const char *pathname, const char *arg, ...);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个子进程,在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid: %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        execl(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid = %d\n&quot;</span>, getpid());  <span class="comment">// 在子进程中这些代码都会被替代掉，不会执行,执行hello可执行文件中的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d , pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>execl()也可以执行操作系统的shell文件</li>
</ul>
</li>
<li><p>execlp()</p>
<ul>
<li>可以从环境变量中查找指定的可执行文件，<strong>如果找到了就执行，找不到就执行不成功。</strong></li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int execlp(const char *file, const char *arg, ... );</span></span><br><span class="line"><span class="comment">        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - file:需要执行的可执行文件的文件名</span></span><br><span class="line"><span class="comment">                a.out</span></span><br><span class="line"><span class="comment">                ps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - arg:是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span></span><br><span class="line"><span class="comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span></span><br><span class="line"><span class="comment">                参数最后需要以NULL结束（哨兵）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span></span><br><span class="line"><span class="comment">            如果调用成功，没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int execv(const char *path, char *const argv[]);</span></span><br><span class="line"><span class="comment">        argv是需要的参数的一个字符串数组</span></span><br><span class="line"><span class="comment">        char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">        execv(&quot;/bin/ps&quot;, argv);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int execve(const char *filename, char *const argv[], char *const envp[]);</span></span><br><span class="line"><span class="comment">        char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/bbb&quot;, &quot;/home/aaa&quot;&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="进程退出、孤儿进程、僵尸进程"><a href="#进程退出、孤儿进程、僵尸进程" class="headerlink" title="进程退出、孤儿进程、僵尸进程"></a>进程退出、孤儿进程、僵尸进程</h3><ul>
<li><p>进程退出</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/74fa7a13e8324d1abe16f733b6a2df8e.png" alt="image-20230828125257042"><ul>
<li>子进程结束之后只能释放用户区的数据，内核区的数据需要父进程去回收</li>
<li>c库的exit()会多做两个事情，如上图</li>
<li>注意：<ul>
<li>标准c库的exit()函数会刷新IO缓冲区，而linux系统中的_exit()不会</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>孤儿进程</p>
<ul>
<li>父进程运行结束，但子进程还在运行。这样的子进程就称为孤儿进程<ul>
<li>当出现孤儿进程时，内核将把孤儿进程的父进程设置为init，而init进程会循环的wait()它的已经退出的子进程，这样，当一个孤儿进程结束了生命周期之后，init进程就会处理它。</li>
<li>因此孤儿进程并不会有什么危害</li>
<li>init进程相当于它的干爹</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/ea1f7f9cc8114de5881a9b752d73e712.png" alt="image-20230828141742090"></p>
</li>
<li><p>僵尸进程</p>
<ul>
<li>每个进程结束后，都会释放自己地址空间中的用户区数据，<strong>内核区的PCB没有办法自己释放掉</strong>，需要父进程去释放</li>
<li>进程终止时，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸进程</li>
<li>僵尸集成不能被kill- 9杀死</li>
<li><img src="https://img-blog.csdnimg.cn/33b46d5000fb4694b37c05f13bfa74c8.png" alt="image-20230828143059721"></li>
<li><strong>僵尸进程是有危害的</strong>，父进程应该时候**wait()或者waitpid()**释放资源</li>
<li>产生原因：<ul>
<li>子进程死了，但是父进程没有回收资源</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/8205e637c7d943afa41fc3b081563dfe.png" alt="image-20230828143505084"></p>
<ul>
<li>可能导致新进程没有可用进程号可分配</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li>将父进程杀死，让僵尸进程变成孤儿进程交给init(进程号位1)进程托管</li>
</ul>
</li>
</ul>
<h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><ul>
<li><p>父进程回收子进程资源</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/80dcd88029ca469c82c015959d224a6f.png" alt="image-20230828144306238"><ul>
<li><strong>PCB中的信息内核不会释放，需要父进程使用wait()和waitpid()得到它的退出状态同时彻底清除掉这个进程</strong></li>
<li>一次调用只能清理一个子进程</li>
</ul>
</li>
</ul>
</li>
<li><p>wait()函数使用</p>
<ul>
<li>使用该函数的进程会挂起</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    功能: 等待任意一个子进程结束,如果任意一个子进程结束了,此函数将会回收子进程资源</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        - wstatus: 进程退出时的状态信息,传入的是一个int类型的地址,传出参数</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">        成功返回被回收的子进程id</span></span><br><span class="line"><span class="comment">        失败返回-1(所有的子进程都结束了,调用函数失败)</span></span><br><span class="line"><span class="comment">    pid_t wait(int *_Nullable wstatus);</span></span><br><span class="line"><span class="comment">    调用wait()函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略的信号时才能被唤醒(继续执行)</span></span><br><span class="line"><span class="comment">    如果没有子进程了,函数立刻返回,返回-1。如果子进程都结束了，也会立即返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 有一个父进程,创建5个子进程(兄弟)</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();  <span class="comment">// 注意这里不止产生5个,需要下面的判断</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            <span class="type">int</span> ret = wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die , pid = %d\n&quot;</span>, ret);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出信息相关宏函数</p>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/8f4205d846f94bc6975b5a0de4891985.png" alt="image-20230828152141644"></p>
<ul>
<li><p>使用</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    功能: 等待任意一个子进程结束,如果任意一个子进程结束了,此函数将会回收子进程资源</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        - wstatus: 进程退出时的状态信息,传入的是一个int类型的地址,传出参数</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">        成功返回被回收的子进程id</span></span><br><span class="line"><span class="comment">        失败返回-1(所有的子进程都结束了,调用函数失败)</span></span><br><span class="line"><span class="comment">    pid_t wait(int *_Nullable wstatus);</span></span><br><span class="line"><span class="comment">    调用wait()函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略的信号时才能被唤醒(继续执行)</span></span><br><span class="line"><span class="comment">    如果没有子进程了,函数立刻返回,返回-1。如果子进程都结束了，也会立即返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 有一个父进程,创建5个子进程(兄弟)</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();  <span class="comment">// 注意这里不止产生5个,需要下面的判断</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            <span class="comment">// int ret = wait(NULL);</span></span><br><span class="line">            <span class="type">int</span> st;</span><br><span class="line">            <span class="type">int</span> ret = wait(&amp;st);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(st)) &#123;</span><br><span class="line">                <span class="comment">// 正常退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出状态码: %d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (WIFSIGNALED(st)) &#123;</span><br><span class="line">                <span class="comment">// 异常终止</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被%d信号干掉了\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die , pid = %d\n&quot;</span>, ret);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    功能:回收指定进程号的子进程，可以设置是否阻塞</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        - pid:</span></span><br><span class="line"><span class="comment">            pid &gt; 0 表示某个子进程的pid</span></span><br><span class="line"><span class="comment">            pid = 0 回收当前进程组的所有子进程</span></span><br><span class="line"><span class="comment">            pid = -1 表示回收所有的子进程,相当于wait()</span></span><br><span class="line"><span class="comment">            pid &lt; -1 某个进程组的组id,绝对值代表该进程组的id，回收指定进程组中的子进程</span></span><br><span class="line"><span class="comment">        - wstatus : 进程退出时的状态信息，传入的是一个int类型的地址，传出参数</span></span><br><span class="line"><span class="comment">        - options:</span></span><br><span class="line"><span class="comment">            0: 阻塞</span></span><br><span class="line"><span class="comment">            WNOHANG: 非阻塞</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        &gt; 0 : 返回子进程的id</span></span><br><span class="line"><span class="comment">        = 0 : options = WNOHANG, 表示还有子进程或者</span></span><br><span class="line"><span class="comment">        = -1: 错误或者没有子进程了</span></span><br><span class="line"><span class="comment">    pid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 有一个父进程，创建5个子进程（兄弟）</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个子进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> st;</span><br><span class="line">            <span class="comment">// int ret = waitpid(-1, &amp;st, 0); // 阻塞的情况</span></span><br><span class="line">            <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, &amp;st, WNOHANG);  <span class="comment">// 非阻塞</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 还有子进程存</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;还有子进程存在\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (WIFEXITED(st)) &#123;</span><br><span class="line">                    <span class="comment">// 是不是正常退出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (WIFSIGNALED(st)) &#123;</span><br><span class="line">                    <span class="comment">// 是不是异常终止</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// exit(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h3><ul>
<li>进程是一个独立的资源分配，不同进程之间的资源是独立的，没有关联，不同的进程间不能之间访问</li>
<li>进程通信的目的<ul>
<li>数据传输</li>
<li>事件通知</li>
<li>资源共享</li>
<li>进程控制</li>
<li><img src="https://img-blog.csdnimg.cn/b4d2d57e73fb4097adbdfad3449a2548.png" alt="image-20230828201621809"></li>
</ul>
</li>
</ul>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a><code>进程间的通信方式</code></h3><ul>
<li><p>同一主机进程间通信</p>
<ul>
<li>UNIX进程间通信方式</li>
</ul>
<blockquote>
<ul>
<li>匿名管道</li>
<li>有名管道</li>
<li>信号</li>
</ul>
</blockquote>
<ul>
<li>System V进程间通信方式</li>
</ul>
<blockquote>
<ul>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
</ul>
</blockquote>
</li>
<li><p>不同主机(因特网)进程间通信</p>
<blockquote>
<p>Socket</p>
</blockquote>
</li>
</ul>
<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><h5 id="匿名管道概述"><a href="#匿名管道概述" class="headerlink" title="匿名管道概述"></a>匿名管道概述</h5><ul>
<li><p>管道也叫无名(匿名)管道，它是UNIX系统IPC(进程间通信)的<strong>最古老形式</strong>，所有的UNIX系统都支持这种通信</p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/4f6d0d8d9b6d46f28a999f17ccff5381.png" alt="image-20230828203304502"></p>
</li>
<li><p>| 称为管道符</p>
<ul>
<li>理解：<ul>
<li>ls指定得到的内容交给后面的指令进行统计</li>
</ul>
</li>
<li>实际：<ul>
<li>两个命令创建<strong>两个进程</strong>，**| 的作用是创建管道，进行通信**，把前面进程运行得到的内容发送给后面进程</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>管道的特点</strong></p>
<ul>
<li>管道其实是一个在内核内存中维护的缓冲器，这个<strong>缓冲器的存储能力是有限</strong>的，不同的操作系统大小不一定相同</li>
<li>管道拥有文件的特质：读操作、写操作。匿名管道没有文件实体，有名管道有文件实体但不存储数据。可以<strong>按照操作文件的方式对管道进行操作</strong></li>
<li>一个管道是一个字节流，使用管道时<strong>不存在消息或消息边界的概念</strong>，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块大小是多少</li>
<li><strong>通过管道传递的数据是顺序的，从管道中读取出来的字节顺序和它们被写入管道的顺序是完全一致的</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/1e97583c3a8c4ee08aa7c88989d4290e.png" alt="image-20230828205350998"></p>
<ul>
<li>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，<strong>管道是半双工的</strong></li>
<li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，无法使用lseek()</li>
<li>匿名管道只能在具有公共祖先的进程之间使用后</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/5a265f9aeae94a278592cf79c680049e.png" alt="image-20230828211325363"></p>
</li>
<li><p>为什么可以使用管道进行进程间通信</p>
<ul>
<li>子进程fork()出来之后跟父进程<strong>共享文件描述符</strong></li>
<li><img src="https://img-blog.csdnimg.cn/4e1eabccfd0e4c3f842493503a4b0cb8.png" alt="image-20230828212604239"><ul>
<li>注意:一定要是有关系的进程</li>
</ul>
</li>
</ul>
</li>
<li><p>管道的数据结构</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/8a6e1e216e434bd1b2ed0660bc42b7a7.png" alt="image-20230828212917829"><ul>
<li>环形队列极大的节省了空间</li>
</ul>
</li>
</ul>
</li>
<li><p>匿名管道的使用</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/599db16dc75e41258b26b58546f4ab2e.png" alt="image-20230828212940361"></li>
</ul>
</li>
<li><p>一个进程发一个进程接收</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    功能: 创建一个匿名管道用来进程间的通信</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - int[2] 这个数组是一个传出参数</span></span><br><span class="line"><span class="comment">          pipe[0] 对应的是管道的读端</span></span><br><span class="line"><span class="comment">          pipe[1] 对应的是管道的写端</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回0</span></span><br><span class="line"><span class="comment">        失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">    注意:匿名管道只能用于具有关系的进程间的通信</span></span><br><span class="line"><span class="comment">    int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="comment">    管道默认是阻塞的，如果管道中没有数据，read阻塞，通过管道满了，write阻塞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建管道,在fork()之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建子进程kenqing</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s , pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="type">char</span>* str = <span class="string">&quot;hello , i am child&quot;</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>管道两端同时发送和接受数据，注意顺序需要相反(不能都先接收或者都先发送)</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="comment">        功能：创建一个匿名管道，用来进程间通信。</span></span><br><span class="line"><span class="comment">        参数：int pipefd[2] 这个数组是一个传出参数。</span></span><br><span class="line"><span class="comment">            pipefd[0] 对应的是管道的读端</span></span><br><span class="line"><span class="comment">            pipefd[1] 对应的是管道的写端</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功 0</span></span><br><span class="line"><span class="comment">            失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;hello,i am parent&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            bzero(buf, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码有什么缺陷？</p>
<ul>
<li><p>如果没有sleep()函数，父子进程可能会一直执行，另一个进程抢不到时间片导致父进程读取自己写的数据或者子进程读取自己写的数据</p>
<p><img src="https://img-blog.csdnimg.cn/7188b463c40b40f5b4f7773a65b1583c.png" alt="image-20230829191742730"></p>
<ul>
<li>如图所示，会发生如上的错误</li>
</ul>
</li>
<li><p>所以管道一般不会用于两个进程互相发送数据</p>
</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p>查看管道的大小fpathconf</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取管道的大小</span></span><br><span class="line">    <span class="type">long</span> size = fpathconf(pipefd[<span class="number">0</span>], _PC_PIPE_BUF);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pipe size : %ld\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="匿名管道通信案例"><a href="#匿名管道通信案例" class="headerlink" title="匿名管道通信案例"></a>匿名管道通信案例</h5> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现ps aux | grep xxx</span></span><br><span class="line"><span class="comment">    子进程: ps aus 子进程结束后,将数据发送给父进程</span></span><br><span class="line"><span class="comment">    父进程: 获取数据 过滤</span></span><br><span class="line"><span class="comment">    pipe()</span></span><br><span class="line"><span class="comment">    execlp()</span></span><br><span class="line"><span class="comment">    子进程将标准输出 stdout_fileno 重定向到管道的写段 dup2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从管道中读取数据</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 过滤数据输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 文件描述符重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        dup2(pipefd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        <span class="comment">// 执行ps aux</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="管道的读写特点和管道设置为非阻塞"><a href="#管道的读写特点和管道设置为非阻塞" class="headerlink" title="管道的读写特点和管道设置为非阻塞"></a>管道的读写特点和管道设置为非阻塞</h5><ul>
<li><p>管道的读写特点</p>
<blockquote>
<ul>
<li>注意一下特殊情况(默认阻塞I&#x2F;O)<ul>
<li>1.如果所有指向管道写端的文件描述符都关闭了，写端的引用计数为0，有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0。就像读到文件末尾一样</li>
<li>2.如果有指向管道写端的文件描述符没有关闭，写端的引用计数大于0，而持有管道写端的进程没有往管道的写端写数据，这个时候有进程从管道中读取数据，那么管道中剩余数据被读取后，再次read会阻塞， 直到管道中有数据可以读了才会读取数据并</li>
<li>3.如果所有指向管道读端的文件描述符都关闭了，读端的引用计数为0，有进程从管道的写端写数据，那么该进程会收到一个信号SIGPIPE，通常会导致进程的异常终止</li>
<li>4..如果有指向管道读端的文件描述符没有关闭，读端的引用计数大于0，而持有管道读端的进程没有从管道中读数据，这个时候有进程从管道中写数据，那么在管道被写满的时候再次write会阻塞，直到管道中有空位置之后才能再次写入数据并返回</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>总结</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/90c8bfa1da2f4586ab419b06350f520c.png" alt="image-20230829200444990"></li>
</ul>
</li>
<li><p>设置管道非阻塞</p>
<ul>
<li>使用fcntl()函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置管道非阻塞</span></span><br><span class="line"><span class="comment">    int flags = fcntl(pipefd[0],GETFL); //获取原来的flag</span></span><br><span class="line"><span class="comment">    flags |= O_NONBLOCK</span></span><br><span class="line"><span class="comment">    fcntl(pipefd[0] , F_SETFL , flags);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 设置读端为非阻塞</span></span><br><span class="line">        <span class="type">int</span> flags = fcntl(pipefd[<span class="number">0</span>], F_GETFL);</span><br><span class="line">        flags |= O_NONBLOCK;</span><br><span class="line">        fcntl(pipefd[<span class="number">0</span>], F_SETFL, flags);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;len: %d\n&quot;</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">            sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h4><h5 id="有名管道介绍及使用"><a href="#有名管道介绍及使用" class="headerlink" title="有名管道介绍及使用"></a>有名管道介绍及使用</h5><ul>
<li><p>匿名管道只能用于亲缘关系的进程间通信。有名管道是克服这个缺点而提出的</p>
</li>
<li><p>有名管道FIFO不同于匿名管道之处在于它提供了一个<strong>路径名与之关联</strong></p>
<ul>
<li>以<strong>FIFO的文件形式存在于文件系统</strong>中，打开方式与打开一个普通文件是一样的</li>
</ul>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/6e12ef5c18374bb19f0fac58978cdf1b.png" alt="image-20230829203957644"></p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/80b063d3abe8482dbfd6be4fa5ad57a7.png" alt="image-20230829204131910"></p>
<ul>
<li>不同之处：<ul>
<li>FIFO有文件实体，但是内容却存放在内存中</li>
<li>FIFO进程退出后文件将继续保存在文件系统中</li>
</ul>
</li>
</ul>
</li>
<li><p>有名管道的使用</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/8d0a29d705544175a215fb64f7c8a293.png" alt="image-20230829204246760"></li>
</ul>
</li>
<li><p>有名管道的注意事项</p>
<ul>
<li>一个只读管道打开时会阻塞，直到一个只写进程打开管道<ul>
<li>反之亦然</li>
</ul>
</li>
</ul>
</li>
<li><p>读管道：</p>
<ul>
<li>管道中有数据，read返回实际读到的字节数</li>
<li>管道无数据：<ul>
<li>管道写端被全部关闭，，read返回0(相当于读到文件末尾)</li>
<li>管道写端没有被全部关闭，read阻塞</li>
</ul>
</li>
</ul>
</li>
<li><p>写管道</p>
<ul>
<li>管道读端被全部关闭，进程异常终止(收到SIGPIPE信号)</li>
<li>管道读端没有全部关闭<ul>
<li>管道已经满了，write会阻塞</li>
<li>管道没有满，write将数据写入并返回实际写入的数据量大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="有名管道实现简单的聊天功能"><a href="#有名管道实现简单的聊天功能" class="headerlink" title="有名管道实现简单的聊天功能"></a>有名管道实现简单的聊天功能</h5><ul>
<li><p>chatA</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断有名管道是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在,创建对应的有名管道fifo1\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在,创建对应的有名管道fifo2\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.以只读的方式打开管道1</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo1&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开fifo1成功,等待读取数据...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.以只写的方式打开管道2</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo2&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开fifo2成功,等待写入数据...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.循环读写数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 5.读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>chatB</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断有名管道是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在,创建对应的有名管道fifo1\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在,创建对应的有名管道fifo2\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.以只写的方式打开管道1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开fifo1成功,等待写入数据...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.以只读的方式打开管道2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开fifo2成功,等待读取数据...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.循环写读数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="内存映射-memory-mapped-I-O"><a href="#内存映射-memory-mapped-I-O" class="headerlink" title="内存映射 memory-mapped I&#x2F;O"></a>内存映射 memory-mapped I&#x2F;O</h4><ul>
<li>将磁盘文件的<strong>数据映射到内存</strong>，用户通过<strong>修改内存就能修改磁盘文件</strong></li>
<li>内存映射的相关系统调用<ul>
<li><img src="https://img-blog.csdnimg.cn/10369eea7199442b98cb94c6a1f43928.png" alt="image-20230830192010155"><ul>
<li>mmap内存映射</li>
<li>mumap内存解映射</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">    功能: 映射一个文件的数据到内存中</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - void * addr:NULL,由内核决定</span></span><br><span class="line"><span class="comment">        - length: 要映射的数据的长度,这个值不能为0,建议使用文件的长度</span></span><br><span class="line"><span class="comment">            获取文件长度 stat 、 lseek</span></span><br><span class="line"><span class="comment">        - prot: 对申请的内存映射区的操作权限</span></span><br><span class="line"><span class="comment">            PROT_EXEC  Pages may be executed.可执行权限</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            PROT_READ  Pages may be read.读权限</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            PROT_WRITE Pages may be written.写权限</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            PROT_NONE  Pages may not be accessed.没有权限</span></span><br><span class="line"><span class="comment">        要操作映射区内存,必须要有读的权限</span></span><br><span class="line"><span class="comment">        - flags:</span></span><br><span class="line"><span class="comment">            - MAP_SHARED: 映射区的数据会自动和磁盘文件进行同步,进程间通信必须要设置这个权限</span></span><br><span class="line"><span class="comment">            - MAP_PRIVATE: 不同步，映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件</span></span><br><span class="line"><span class="comment">        - fd: 需要映射的那个文件的文件描述符</span></span><br><span class="line"><span class="comment">            -通过open得到，open的是一个磁盘文件</span></span><br><span class="line"><span class="comment">            -注意:文件的大小不能为0,open指定的权限不能和prot参数有冲突</span></span><br><span class="line"><span class="comment">                PROT: PROT_READ-&gt;open:只读/读写</span></span><br><span class="line"><span class="comment">                PROT: PROT_READ | PROT_WRITE open:只能是读写</span></span><br><span class="line"><span class="comment">        - offset: 偏移量,一般不用。碧玺指定的是4k的整数倍，0表示不偏移，从文件开头</span></span><br><span class="line"><span class="comment">        返回:返回创建的内存的首地址</span></span><br><span class="line"><span class="comment">            失败返回MAP_FAILED.（void*) -1</span></span><br><span class="line"><span class="comment">    void *mmap(void addr[.length], size_t length, int prot, int flags,int fd, off_t offset);</span></span><br><span class="line"><span class="comment">    int munmap(void addr[.length], size_t length);</span></span><br><span class="line"><span class="comment">    功能:释放内存映射</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - addr: 要释放的内存的首地址</span></span><br><span class="line"><span class="comment">        - length 要释放的大小，与mmap中的length一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用内存映射实现进程间通信:</span></span><br><span class="line"><span class="comment">        1.有关系的进程(父子进程)</span></span><br><span class="line"><span class="comment">            -在没有子进程的时候创建内存映射区</span></span><br><span class="line"><span class="comment">            -有了内存映射区之后再创建子进程</span></span><br><span class="line"><span class="comment">            -父子进程共享创建的内存映射区</span></span><br><span class="line"><span class="comment">        2.没有关系的进程</span></span><br><span class="line"><span class="comment">            -准备大小不是0的磁盘文件</span></span><br><span class="line"><span class="comment">            -进程1，通过磁盘文件创建内存映射区</span></span><br><span class="line"><span class="comment">                -得到一个操作这块内存的指针</span></span><br><span class="line"><span class="comment">            -进程2，通过磁盘文件创建内存映射区</span></span><br><span class="line"><span class="comment">                -得到一个操作这块内存的指针</span></span><br><span class="line"><span class="comment">            -使用内存映射区进行通信</span></span><br><span class="line"><span class="comment">    注意:内存映射区是非阻塞的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有关系的进程通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.打开这个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span>*)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr, <span class="string">&quot;nihao a , son!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h5><ul>
<li><p>1.如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?</p>
<blockquote>
<p>void* ptr &#x3D; mmap(…);</p>
<p>可以对ptr进行操作但是不建议，导致munmap(…)&#x2F;&#x2F; 错误,要保存地址</p>
</blockquote>
</li>
<li><p>2.如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?</p>
<blockquote>
<p>错误，返回MAP_FAILED<br>open()函数中的权限建议和prot参数的权限保持一致。</p>
<p>prot的权限≤open的权限</p>
</blockquote>
</li>
<li><p>3.如果文件偏移量为1000会怎样?</p>
<blockquote>
<p>偏移量要求是4k的整数倍,会返回错误MAP_FAILED</p>
</blockquote>
</li>
<li><p>4.mmap什么情况下会调用失败?</p>
<blockquote>
<ul>
<li>第二个参数length &#x3D; 0</li>
<li>第三个参数prot权限没有指定读权限</li>
<li>第三个参数prot权限大于open的权限</li>
</ul>
</blockquote>
</li>
<li><p>5.可以open的时候O_CREAT一个新文件来创建映射区吗?、</p>
<blockquote>
<ul>
<li>可以的，但是创建的文件的大小如果为0的话，肯定不行<ul>
<li>可以对新的文件进行扩展<ul>
<li>lseek()</li>
<li>truncate()</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>6.mmap后关闭文件描述符，对mmap映射有没有影响？</p>
<blockquote>
<p> int fd &#x3D; open(“XXX”);<br> mmap(,,,,fd,0);<br> close(fd);</p>
<p> 映射区还在,创建映射区的fd被关闭没有任何影响</p>
</blockquote>
</li>
<li><p>7.对ptr越界操作会怎样？</p>
<blockquote>
<p>void * ptr &#x3D; mmap(NULL, 100,,,,,);<br>4K<br>越界操作操作的是非法的内存 -&gt; 段错误</p>
</blockquote>
</li>
</ul>
<p>文件复制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用内存映射实现文件复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路:</span></span><br><span class="line"><span class="comment">        1.对原始的文件进行内存映射</span></span><br><span class="line"><span class="comment">        2.创建一个新文件，拓展新文件</span></span><br><span class="line"><span class="comment">        3.把新文件数据映射到内存中</span></span><br><span class="line"><span class="comment">        4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.对原始的文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始文件的大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建一个新文件，拓展新文件</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.把新文件数据映射到内存中</span></span><br><span class="line">    <span class="type">void</span> * ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> * ptr1 = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.释放资源 遵循FILO原则</span></span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line">    munmap(ptr, len);</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    匿名映射：不需要文件实体进程一个内存映射</span></span><br><span class="line"><span class="comment">    只能用于父子进程间的映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">void</span>* ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父子进程间通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = munmap(ptr, len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><ul>
<li><p>是事件发生时对进程的通知机制，也称之为软件中断。异步通信</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/edde410d7c69434c8572db280a7fff26.png" alt="image-20230830221142315"></li>
<li><img src="https://img-blog.csdnimg.cn/ff4afdf27c54435ca4bbf0cbfd34873a.png" alt="image-20230830221548859"></li>
</ul>
</li>
<li><p>使用信号的目的</p>
<ul>
<li>让进程知道已经发生了一个特定事情</li>
<li>强迫进程执行它自己代码中的信号处理程序</li>
</ul>
</li>
<li><p>信号的特点</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/e508cef57d664daca62221ab6c867733.png" alt="image-20230830221810161"></p>
</li>
<li><p>kill -l</p>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/08dc8c5c811a42548fea8f68f68022d4.png" alt="image-20230830221946836"></p>
<ul>
<li>1-31号信号是linux操作系统的常规信号</li>
<li>34-64是预定义好的信号，目前还没有使用</li>
</ul>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/c44bf60d9a6d43cf84d705033f91f7bc.png" alt="image-20230830222044955"></p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/69439d5b50ce4da3921b374d8e1658ee.png" alt="image-20230830222431955"></p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/54975478457540cfa0c10724b112d88e.png" alt="image-20230830222630578"></p>
<ul>
<li>特别注意标红信号</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c141605b97aa449290e204e3d3512131.png" alt="image-20230830222702645"></p>
</li>
</ul>
</li>
<li><p>信号的五种默认处理动作</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/b1b1b3ade7f24cc797bb9d2edbc43f46.png" alt="image-20230830223215080"><ul>
<li>当进程收到信号后，必须做以上五件事情之一</li>
<li>core保存进程异常退出的错误信息。<ul>
<li>ulimit -a 查看</li>
<li>ulimit -c 大小 设置产生错误信息文件core的大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="kill、raise、abort函数"><a href="#kill、raise、abort函数" class="headerlink" title="kill、raise、abort函数"></a>kill、raise、abort函数</h5><ul>
<li><p><img src="https://img-blog.csdnimg.cn/2f7f9fbe7d3c4f58abcc36fd908a86d9.png" alt="image-20230831090449637"></p>
</li>
<li><p>代码示例</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">    功能:给某个进程pid发送某个信号sig 。任何进程发送任何信号</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        - pid: 需要发送给的进程id</span></span><br><span class="line"><span class="comment">            pid &gt; 0: 将信号发送给指定的进程</span></span><br><span class="line"><span class="comment">            pid = 0: 将信号发送给当前进程组</span></span><br><span class="line"><span class="comment">            pid = -1: 将信号发送给每一个有权限接受这个信号的进程</span></span><br><span class="line"><span class="comment">            pid &lt; -1: 这个pid是某个进程组的PID取反,0表示不发送任何信号</span></span><br><span class="line"><span class="comment">        - sig: 需要发送的信号的编号或者是宏值(两者等价,建议使用宏值)</span></span><br><span class="line"><span class="comment">    int kill(pid_t pid, int sig);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">    功能:给当前进程发送信号,等同于kill(getpid(),sig);</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -sig: 表示要发送的信号</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回0</span></span><br><span class="line"><span class="comment">        失败返回非0</span></span><br><span class="line"><span class="comment">    int raise(int sig);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">    功能:发送SIGABRT信号给当前进程,杀死当前进程 等同于kill(getpid(),SIGABRT);</span></span><br><span class="line"><span class="comment">    void abort(void);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process%d\n&quot;</span>, i);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent kills child process\n&quot;</span>);</span><br><span class="line">        kill(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li></li>
</ul>
<h5 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h5><ul>
<li><p><img src="https://img-blog.csdnimg.cn/2eb7d1e63d894129bbf338fbb012e1dc.png" alt="image-20230831093120547"></p>
</li>
<li><p>alarm使用方式</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    功能:设置定时器</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        - seconds:函数调用开始倒计时，当倒计时为0时，函数给当前进程发送一个信号:SIGALARM,进程终止</span></span><br><span class="line"><span class="comment">                  单位:秒 若参数为0，定时器无效</span></span><br><span class="line"><span class="comment">                  取消定时器：通过alarm(0)</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">    - 之前有定时器，返回之前定时器剩余时间</span></span><br><span class="line"><span class="comment">    - 之前没有定时器，返回0</span></span><br><span class="line"><span class="comment">    -SIGALARML: 默认终止当前的进程，每一个进程都有且仅有唯一的一个定时器</span></span><br><span class="line"><span class="comment">                重复调用会刷新定时器,返回的是之前定时器剩余的时间</span></span><br><span class="line"><span class="comment">    unsigned int alarm(unsigned int seconds);</span></span><br><span class="line"><span class="comment">    该函数是不阻塞的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> seconds = alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一次调用 seconds: %d\n&quot;</span>, seconds);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    seconds = alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;休眠两秒后第二次调用 seconds: %d\n&quot;</span>, seconds);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>案列：查看电脑一秒能往文件中写多少个数</p>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1秒电脑能数多少个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>* 实际时间 = 内核时间 + 用户时间(代码执行) + 消耗时间(I/O)、
* 进行文件IO操作非常浪费时间
</code></pre>
<ul>
<li><p><strong>定时器与进程的状态无关(自然定时法)</strong></p>
<ul>
<li>无论进程处于什么状态，alarm()都会计时</li>
</ul>
</li>
</ul>
<h5 id="setitimer定时器函数"><a href="#setitimer定时器函数" class="headerlink" title="setitimer定时器函数"></a>setitimer定时器函数</h5><ul>
<li>使用方式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">    功能: 设置定时器(闹钟),可以替代alarm,精度微秒us,实现周期性定时</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        - which: 定时器以什么时间计时</span></span><br><span class="line"><span class="comment">                ITIMER_REAL: 真实时间,时间到达,发送SIGALARM信号 常用</span></span><br><span class="line"><span class="comment">                ITIMER_VIRTUAL: 用户时间,时间到达,发送SIGVTALRM信号</span></span><br><span class="line"><span class="comment">                ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算</span></span><br><span class="line"><span class="comment">        - new_value: 设置定时器时间属性,</span></span><br><span class="line"><span class="comment">            struct itimerval &#123;              //定时器结构体</span></span><br><span class="line"><span class="comment">               struct timeval it_interval;  //每个阶段的时间,间隔时间</span></span><br><span class="line"><span class="comment">               struct timeval it_value;     //延迟多长时间执行定时器</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           struct timeval &#123;           // 时间结构体</span></span><br><span class="line"><span class="comment">               time_t      tv_sec;    //秒</span></span><br><span class="line"><span class="comment">               suseconds_t tv_usec;   //微秒</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment">        - old_value: 记录上一次的定时的时间参数 ,一般不使用,传递NULL</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">        成功为0</span></span><br><span class="line"><span class="comment">        失败-1并设置错误号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int setitimer(int which, const struct itimerval *restrict new_value,</span></span><br><span class="line"><span class="comment">                     struct itimerval *_Nullable restrict old_value);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line">    <span class="comment">// 设置值 过3秒以后,每隔两秒定时一次</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;  <span class="comment">// 设置延迟时间</span></span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;  <span class="comment">// 设置间隔时间</span></span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);  <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="signal信号"><a href="#signal信号" class="headerlink" title="signal信号"></a>signal信号</h5><ul>
<li>setitimer不能看到周期性的循环，发的是结束进程的信号</li>
<li>signal<strong>可以捕捉信号</strong>，解决了setitimer不能捕捉信号的缺点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">    typedef void (*sighandler_t)(int);</span></span><br><span class="line"><span class="comment">    功能：设置某个信号的捕捉行为</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        - signum: 要捕捉的信号</span></span><br><span class="line"><span class="comment">        - handler: 捕捉到信号后如何处理</span></span><br><span class="line"><span class="comment">            SIG_IGN: 忽略信号</span></span><br><span class="line"><span class="comment">            SIG_DFL: 默认信号,使用信号默认行为</span></span><br><span class="line"><span class="comment">            回调函数: 这个函数是内核调用,程序员只负责写,捕捉到信号后如何去处理信号</span></span><br><span class="line"><span class="comment">                -需要程序员实现并且提前准备好，函数类型根据实际需求，看函数指针定义</span></span><br><span class="line"><span class="comment">                -不需要程序员调用,而是当信号产生时由内核调用</span></span><br><span class="line"><span class="comment">                -函数指针是实现回调的手段。函数实现之后,将函数名放到函数指针的位置就可以了</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">        成功返回上一次注册的信号处理函数的地址,第一次调用返回NULL</span></span><br><span class="line"><span class="comment">        失败返回宏SIG_ERR,设置错误号</span></span><br><span class="line"><span class="comment">    sighandler_t signal(int signum, sighandler_t handler);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意: The signals SIGKILL and SIGSTOP cannot be caught or ignored.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是%d\n&quot;</span>,num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是回调函数\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//注册信号捕捉</span></span><br><span class="line">    signal(SIGALRM,myalarm);</span><br><span class="line">    <span class="comment">//typedef void (*sighandler_t)(int); 函数指针 sighandler_t是函数指针的名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义信号集相关函数"><a href="#自定义信号集相关函数" class="headerlink" title="自定义信号集相关函数"></a>自定义信号集相关函数</h5><ul>
<li><p>信号集</p>
<ul>
<li>信号组成的集合 <strong>sigset_t</strong> 整型</li>
<li><img src="https://img-blog.csdnimg.cn/ac12af3b281e4936ad69865540cad065.png" alt="image-20230901125922741"></li>
</ul>
</li>
<li><p><strong>PCB中两个重要的信号集</strong></p>
<ul>
<li><strong>阻塞信号集</strong>和<strong>未决信号集</strong><ul>
<li>这两个信号集都是内核使用<strong>位图机制</strong>来实现的(二进制位)</li>
<li>不能直接对这两个信号集进行位操作。需要自定义另一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改</li>
</ul>
</li>
<li>未决：是一种状态机。指的是信号的产生到信号被处理签的这一段事件</li>
<li>阻塞：是一个开关动作，指的是<strong>阻止信号被处理</strong>，而不是阻止信号的产生<ul>
<li>阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下的信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作</li>
</ul>
</li>
</ul>
</li>
<li><p>工作原理</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/4159db4e36844a70aff6cb3b7597a7d0.png" alt="image-20230901131201436"></li>
</ul>
<blockquote>
<p>1.用户通过键盘 Ctrl + C,产生2号信号SIGINT(信号被创建)</p>
<p>2.此时信号产生但是没有被处理(未决)</p>
<ul>
<li>在内核中将<strong>所有的没有被处理的信号存储在一个集合中</strong>，这个集合被称为<strong>未决信号集</strong></li>
<li>SIGINT信号状态被存储在第二个标志位</li>
<li>这个标志位的值为0，说明信号不处于未决状态</li>
<li>这个标志位的值为1，说明信号处于未决状态</li>
<li>这个未决状态的信号需要被处理，处理之前需要和另一个信号集(阻塞信号集)进行比较。</li>
<li>阻塞信号集中对应信号的标志位的值若为1，表示阻塞，信号一直处于未决状态直到阻塞接触；若值为0，处理该信号，处理完成之后未决信号集中对应的标志位值置为0</li>
<li>若想要阻塞某些信号，需要调用系统API</li>
</ul>
</blockquote>
</li>
<li><p>跟信号集相关的函数</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/60a24c97ebb54477bef89ea7860b2984.png" alt="image-20230901132138872"></li>
</ul>
</li>
<li><p>这里出现的函数只能<strong>对自定义的信号集进行操作</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">    以下信号集相关函数都是对自定义的信号集进行操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sigemptyset(sigset_t *set);</span></span><br><span class="line"><span class="comment">        功能:清空信号集中的数据，将信号集中的所有的标志位置为0</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - set:传出参数，是我们需要操作的信号集</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">            成功返回0</span></span><br><span class="line"><span class="comment">            失败返回-1</span></span><br><span class="line"><span class="comment">    int sigfillset(sigset_t *set);</span></span><br><span class="line"><span class="comment">        功能:将信号集中所有的标志位置为1</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - set:传出参数，是我们需要操作的信号集</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">            成功返回0</span></span><br><span class="line"><span class="comment">            失败返回-1</span></span><br><span class="line"><span class="comment">    int sigaddset(sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment">    功能:设置信号集中的某一个信号对应的标志位为1,表示阻塞这个信号</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - set:传出参数，是我们需要操作的信号集</span></span><br><span class="line"><span class="comment">            - signum: 需要设置阻塞的信号</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">            成功返回0</span></span><br><span class="line"><span class="comment">            失败返回-1</span></span><br><span class="line"><span class="comment">    int sigdelset(sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment">        功能:设置信号集中的某一个信号对应的标志位为0,表示不阻塞这个信号</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - set:传出参数，是我们需要操作的信号集</span></span><br><span class="line"><span class="comment">            - signum: 需要设置不阻塞的信号</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">            成功返回0</span></span><br><span class="line"><span class="comment">            失败返回-1</span></span><br><span class="line"><span class="comment">    int sigismember(const sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment">        功能:判断某个信号是否阻塞</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - set:是我们需要操作的信号集</span></span><br><span class="line"><span class="comment">            - signum: 需要判断的信号</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">            1:signum被阻塞</span></span><br><span class="line"><span class="comment">            0:signum不阻塞</span></span><br><span class="line"><span class="comment">            -1:失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">//清空信号集</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断SIGINT是否在信号集set里</span></span><br><span class="line">    <span class="type">int</span> ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT不阻塞\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加几个信号到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="comment">//判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT不阻塞\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从信号集中删除信号</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">     ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT不阻塞\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h5><ul>
<li>对<strong>内核的信号集进行操作</strong></li>
<li>内核信号集不能直接修改，需要先自定义信号集，用自定义的信号集去设置内核中的信号集，这里就需要使用sigprocmask函数和上图中的最后一个函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">    功能: 将自定义信号集中的数据设置到内核中(设置阻塞,解除阻塞,替换)</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - how: 如何对内核中阻塞的信号集进行处理</span></span><br><span class="line"><span class="comment">            SIG_BLOCK:将用户设置的阻塞信号集添加到内核中,内核中原来的数据不变</span></span><br><span class="line"><span class="comment">                      假设内核中，默认的阻塞信号集是mask: mask | set</span></span><br><span class="line"><span class="comment">            SIG_UNBLOCK: 根据用户设置的数据,对内核中的数据进行解除阻塞</span></span><br><span class="line"><span class="comment">                        mask &amp;= ~set</span></span><br><span class="line"><span class="comment">            SIG_SETMASK: 覆盖内核中原来的值</span></span><br><span class="line"><span class="comment">        - set: 已经初始化好的用户自定义的信号集</span></span><br><span class="line"><span class="comment">        -oldset: 保存设置之前的内核中的阻塞信号集的状态，一般不使用，NULL</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回 0</span></span><br><span class="line"><span class="comment">        失败返回 -1 设置错误号EFAULT、EINVAL</span></span><br><span class="line"><span class="comment">    int sigprocmask(int how, const sigset_t *_Nullable restrict set,</span></span><br><span class="line"><span class="comment">                                  sigset_t *_Nullable restrict oldset);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    功能: 获取内核中的未决信号集</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        -set: 传出参数,保存的是未决中的传出信号集中的信息</span></span><br><span class="line"><span class="comment">    int sigpending(sigset_t *set);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目的:将所有的常规信号(1-31)的未决状态打印到屏幕</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">// 设置2和3号信号阻塞</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="comment">// 修改内核中的阻塞信号集</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前未决信号集的数据</span></span><br><span class="line">        <span class="type">sigset_t</span> pendingset;</span><br><span class="line">        sigemptyset(&amp;pendingset);</span><br><span class="line">        sigpending(&amp;pendingset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigismember(&amp;pendingset, i) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sigismember(&amp;pendingset, i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;sigismenber&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">//解除阻塞</span></span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="sigaction信号捕捉函数"><a href="#sigaction信号捕捉函数" class="headerlink" title="sigaction信号捕捉函数"></a>sigaction信号捕捉函数</h5><ul>
<li><p>建议使用sigaction,因为signal是美国定义的，不同标准下结果可能不一样</p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/f087e957c5ad408289955888d741e78a.png" alt="image-20230901160954448"></p>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">    功能：检查或者改变信号的处理。信号捕捉</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - signum: 需要捕捉的信号的编号或者宏值(信号的名称)</span></span><br><span class="line"><span class="comment">        -act:捕捉到信号之后相应的处理动作</span></span><br><span class="line"><span class="comment">        -oldact:一般为NULL,上一次信号捕捉相关的设置</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回0,失败返回-1</span></span><br><span class="line"><span class="comment">    int sigaction(int signum, struct sigaction * act,</span></span><br><span class="line"><span class="comment">                struct sigaction * oldact);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    struct sigaction &#123;</span></span><br><span class="line"><span class="comment">            void     (*sa_handler)(int); //函数指针,只想的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line"><span class="comment">            void     (*sa_sigaction)(int, siginfo_t *, void *); //不常用,</span></span><br><span class="line"><span class="comment">            sigset_t   sa_mask; //临时阻塞信号集，在信号捕捉函数执行过程中,临时阻塞某些信号</span></span><br><span class="line"><span class="comment">            int        sa_flags; //   使用哪一个信号对捕捉到的信号进行处理 0表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line"><span class="comment">            void     (*sa_restorer)(void); //被废弃掉,NULL</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是回调函数\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myalarm;</span><br><span class="line">    <span class="comment">// 清空临时阻塞信号集</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// typedef void (*sighandler_t)(int); 函数指针 sighandler_t是函数指针的名称</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sigchild信号"><a href="#sigchild信号" class="headerlink" title="sigchild信号"></a>sigchild信号</h5><ul>
<li><p>产生的三个条件</p>
<ul>
<li>子进程终止</li>
<li>子进程接收到SIGSTOP信号停止,注意这里不是进程结束,而是处于暂停态</li>
<li>子进程处于停止态，接受到SIGCONT后唤醒时</li>
</ul>
</li>
<li><p>发送sigchild是由内核发送给父进程的信号，父进程默认忽略该信号</p>
<ul>
<li>可以解决僵尸进程的问题</li>
<li>避免父进程使用wait()盲目等待</li>
</ul>
</li>
<li><p>案例</p>
<ul>
<li>注意:提前设置好阻塞信号集,阻塞SIGCHLD,因为有可能子进程很快结束,父进程还没有注册完信号捕捉</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号: %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 回收子进程的资源</span></span><br><span class="line">    <span class="comment">// while (1) &#123;</span></span><br><span class="line">    <span class="comment">//     wait(NULL);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有子进程了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 提前设置好阻塞信号集,阻塞SIGCHLD,因为有可能子进程很快结束,父进程还没有注册完信号捕捉</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕捉子进程死亡时发送的sigchild信号</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册完信号捕捉以后,就解除阻塞</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid: %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process oid: %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><ul>
<li><p>是<strong>效率最高</strong>的进程间通信方式</p>
</li>
<li><p>允许两个或者多个进程共<strong>享物理内存的同一块区域(通常被称为段)。</strong>由于一个共享内存段会成为一个进程用户空间的一部分。因此这种IPC机制<strong>无需内核介入</strong>(并不是完全不需要)。</p>
</li>
<li><p>一个进程将数据复制进共享内存中，并且这部分数据对其他所有共享同一个段的进程可用</p>
<p><img src="https://img-blog.csdnimg.cn/74638319217b43c59a8c04fef51164c0.png" alt="image-20230902142550015"></p>
</li>
<li><p>共享内存使用步骤</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/27c6b9cb92b7498b8046d13066da30b2.png" alt="image-20230902142831824"></li>
</ul>
<blockquote>
<ul>
<li>1.调用shmget()，创建一个新的共享内存或者取得一个既有共享内存段的标识符。这个调用返回后续调用中需要用到的共享内存标识符</li>
<li>2.使用shmat()来附上共享内存段，使该段称为调用进程的虚拟内存的一部分。</li>
<li>3.shmat()返回值addr指向进程的虚拟地址空间中该共享内存段的起点</li>
<li>4.调用shmdt()来分离共享内存段。调用之后，进程就无法再引用这块共享内存了。</li>
<li>5.调用shmctl()来删除共享内存段。只需要一个进程执行这一步</li>
</ul>
</blockquote>
</li>
<li><p>共享内存操作函数</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/cb46ac1873be4f0ebff9591ca5c15bbc.png" alt="image-20230902144012388"></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">共享内存相关的函数</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="line">        新创建的内存段中的数据都会被初始化为<span class="number">0</span></span><br><span class="line">    - 参数：</span><br><span class="line">        - key : <span class="type">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="line">                一般使用<span class="number">16</span>进制表示，非<span class="number">0</span>值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：<span class="number">-1</span> 并设置错误号</span><br><span class="line">            成功：&gt;<span class="number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定<span class="literal">NULL</span>，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： <span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  失败(<span class="type">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁</span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line">    - 功能：根据指定的路径名，和<span class="type">int</span>值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">            / </span><br><span class="line">        - proj_id: <span class="type">int</span>类型的值，但是这系统调用只会使用其中的<span class="number">1</span>个字节</span><br><span class="line">                   范围 ： <span class="number">0</span><span class="number">-255</span>  一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题<span class="number">1</span>：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体<span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> 这个结构体中有一个成员 <span class="title">shm_nattch</span></span></span><br><span class="line"><span class="class">    - <span class="title">shm_nattach</span> 记录了关联的进程个数</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">问题2：可不可以对共享内存进行多次删除 <span class="title">shmctl</span></span></span><br><span class="line"><span class="class">    - 可以</span></span><br><span class="line"><span class="class">    - 因为<span class="title">shmctl</span> 标记删除共享内存，不是直接删除</span></span><br><span class="line"><span class="class">    - 什么时候真正删除呢?</span></span><br><span class="line"><span class="class">        当和共享内存关联的进程数为0的时候，就真正被删除</span></span><br><span class="line"><span class="class">    - 当共享内存的<span class="title">key</span>为0的时候，表示共享内存被标记删除了</span></span><br><span class="line"><span class="class">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    共享内存和内存映射的区别</span></span><br><span class="line"><span class="class">    1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span></span><br><span class="line"><span class="class">    2.共享内存效果更高</span></span><br><span class="line"><span class="class">    3.内存</span></span><br><span class="line"><span class="class">        所有的进程操作的是同一块共享内存。</span></span><br><span class="line"><span class="class">        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</span></span><br><span class="line"><span class="class">    4.数据安全</span></span><br><span class="line"><span class="class">        - 进程突然退出</span></span><br><span class="line"><span class="class">            共享内存还存在</span></span><br><span class="line"><span class="class">            内存映射区消失</span></span><br><span class="line"><span class="class">        - 运行进程的电脑死机，宕机了</span></span><br><span class="line"><span class="class">            数据存在在共享内存中，没有了</span></span><br><span class="line"><span class="class">            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    5.生命周期</span></span><br><span class="line"><span class="class">        - 内存映射区：进程退出，内存映射区销毁</span></span><br><span class="line"><span class="class">        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</span></span><br><span class="line"><span class="class">            如果一个进程退出，会自动和共享内存进行取消关联。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>共享内存操作命令</p>
<p><img src="https://img-blog.csdnimg.cn/053a747fad264c1a91d50821f596252e.png" alt="image-20230902154949940"></p>
</li>
<li><p>共享内存使用示例</p>
</li>
<li><p>写端</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid: %d\n&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span>* ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 3.写数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读端</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid: %d\n&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span>* ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进程间通信方式及应用场景总结"><a href="#进程间通信方式及应用场景总结" class="headerlink" title="进程间通信方式及应用场景总结"></a>进程间通信方式及应用场景总结</h3><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><blockquote>
<p>进程间数据间的<strong>简单传输</strong></p>
</blockquote>
<ul>
<li>用于进程间的<strong>简单的数据传输</strong><ul>
<li>若是父子进程间通信，用无名管道就行。pipe()创建管道</li>
<li>若是不同进程间的简单通信，用有名管道，mkfifo()创建管道</li>
</ul>
</li>
</ul>
<h4 id="共享内存-1"><a href="#共享内存-1" class="headerlink" title="共享内存"></a>共享内存</h4><blockquote>
<p> 当不同进程间<strong>需要共享数据</strong>时，需要用到共享内存</p>
</blockquote>
<ul>
<li><p>内存映射：映射一个文件的数据到内存中</p>
<ul>
<li>mmap创建一块共享内存，返回指向这块内存的指针，多个进程共享这一块内存</li>
<li></li>
</ul>
</li>
<li><p>内存共享：<strong>效率最高的一种通信方式</strong></p>
<ul>
<li>一个进程将数据复制进共享内存中，并且这部分数据对其他所有共享同一个段的进程可用</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="number">1.</span>调用<span class="built_in">shmget</span>()，创建一个新的共享内存或者取得一个既有共享内存段的标识符。这个调用返回后续调用中需要用到的共享内存标识符</span><br><span class="line">- <span class="number">2.</span>使用<span class="built_in">shmat</span>()来附上共享内存段，使该段称为调用进程的虚拟内存的一部分。</span><br><span class="line">- <span class="number">3.</span><span class="built_in">shmat</span>()返回值addr指向进程的虚拟地址空间中该共享内存段的起点</span><br><span class="line">- <span class="number">4.</span>调用<span class="built_in">shmdt</span>()来分离共享内存段。调用之后，进程就无法再引用这块共享内存了。</span><br><span class="line">- <span class="number">5.</span>调用<span class="built_in">shmctl</span>()来删除共享内存段。只需要一个进程执行这一步</span><br></pre></td></tr></table></figure>

<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><blockquote>
<p>是进程间同步的一种机制。用于管理多个进程对于共享资源的访问</p>
</blockquote>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><blockquote>
<p><strong>使用于进程间大量传递数据的情况</strong></p>
</blockquote>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><blockquote>
<p><strong>用于不同计算机中的进程通信</strong></p>
</blockquote>
<hr>
<h3 id="进程组、会话"><a href="#进程组、会话" class="headerlink" title="进程组、会话"></a>进程组、会话</h3><ul>
<li>终端：<ul>
<li>在UNIX系统中，用户通过终端登录系统后得到一个shell进程，这个终端成为shell进程的控制终端</li>
<li>进程中，<strong>控制终端是保存在PCB中的信息</strong>，而fork()会复制PCB中的信息，因此由shell进程启动的其他进程的控制终端也是这个终端</li>
<li>标准输入和标准错误输出默认情况下都指向控制终端</li>
</ul>
</li>
<li><img src="https://img-blog.csdnimg.cn/acac426f2c254ec2aab6216c80b9a437.png" alt="image-20230902191058750"></li>
<li>进程组<ul>
<li><strong>进程组是很多进程的集合，会话是一组相关进程组的集合</strong></li>
<li>进程组和会话是为了支持<strong>shell作用</strong>控制而定义的抽象概念，用户通过shell能够交互式地在前台后后台运行命令</li>
<li>进程组组成<ul>
<li>一个或多个共享同一进程组标识符PGID的进程组成。</li>
<li>一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程ID是该进程组的PGID。新进程会继承其父进程所属的进程组ID</li>
</ul>
</li>
<li><img src="https://img-blog.csdnimg.cn/58b7698386d342f7830c5be596901fe2.png" alt="image-20230902192641858"></li>
</ul>
</li>
<li>会话<ul>
<li><img src="https://img-blog.csdnimg.cn/53416d5ab75c4819bb33fa6d2beba13c.png" alt="image-20230902192807449"></li>
</ul>
</li>
<li>进程组、会话、控制终端之间的关系<ul>
<li><img src="https://img-blog.csdnimg.cn/3a3b7012ad47412581c02dbf0bd80f06.png" alt="image-20230902193608403"></li>
</ul>
</li>
</ul>
<h4 id="进程组、会话操作函数"><a href="#进程组、会话操作函数" class="headerlink" title="进程组、会话操作函数"></a>进程组、会话操作函数</h4><p>* </p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/1a6359b7141b430f814bb37196c2c865.png" alt="image-20230902193743447"></li>
</ul>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul>
<li><p><strong>是linux中的后台服务进程</strong>。生存周期较长，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件，<strong>通常以d结尾</strong></p>
<ul>
<li><strong>后台进程，周期性的执行某些事情</strong></li>
</ul>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/d1a08ddc94b24190a344c73f7c1aa27f.png" alt="image-20230902193933928"></p>
</li>
<li><p><strong>系统启动时候被创建，一直运行直到系统关闭</strong></p>
</li>
<li><p>守护进程的<strong>创建步骤</strong></p>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/814a03a5411a4ef78d58f6a52e2f6e05.png" alt="image-20230902195356397"></p>
</li>
<li><p>退出父进程是避免父进程结束时终端出现提示符</p>
<p>调用setsid()不会现控制终端，创建新的会话，用子进程是为了避免出现进程组id相同的进程组</p>
</li>
</ul>
</li>
<li><p>守护进程代码示例</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    写一个守护进程,每隔两秒获取系统时间,将这个时间写入到磁盘文件中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 捕捉到信号之后，获取系统时间，写入磁盘</span></span><br><span class="line">    <span class="type">time_t</span> tm = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 转换格式</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">loc</span> =</span> localtime(&amp;tm);</span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line">    <span class="comment">// sprintf(buf, &quot;%d-%d-%d %d:%d:%d\n&quot;, loc-&gt;tm_year, loc-&gt;tm_mon, loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min, loc-&gt;tm_sec);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* str = asctime(loc);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.将子进程提升为会话</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置掩码</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.更改工作目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/home/yjx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.关闭,重定向文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null/&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕捉定时信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = work;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">10</span>);  <span class="comment">// 死循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h2><h3 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h3><ul>
<li><img src="https://img-blog.csdnimg.cn/7b36c8dbb04249ad8f718d5facff8240.png" alt="image-20230904090526122"><ul>
<li>一个进程可以有多个线程，<strong>同一个程序中的所有线程</strong>独立执行相同程序，共享同一份全局内存区域</li>
<li>进程是CPU分配资源的基本单位，线程是操作系统调度执行的最小单位</li>
<li>Linux是轻量级的进程LWP。在Linux环境下线程的本质还是进程</li>
<li>LWP是线程号</li>
</ul>
</li>
<li>进程和线程的区别<ul>
<li><img src="https://img-blog.csdnimg.cn/d22201db18ea4534af20b8dab18ad33c.png" alt="image-20230904091130967"></li>
<li>进程开销大，信息难以共享</li>
<li>线程方便创建，快速共享信息</li>
</ul>
</li>
<li>进程的创建<ul>
<li><strong>拷贝一份新的虚拟地址空间</strong><ul>
<li>读时共享，写时复制</li>
</ul>
</li>
</ul>
</li>
<li>线程的创建<ul>
<li><strong>共享原来虚拟地址空间</strong>。text段和栈空间分成多份给不同线程。其他的段所有线程共 享</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/7ec2788a5741448182dc0c176af3ffd3.png" alt="image-20230904091608030"></p>
<ul>
<li><p>线程之间共享和不共享的资源</p>
<p><img src="https://img-blog.csdnimg.cn/6100315b419a430d86b0c57bd20ab3ea.png" alt="image-20230904091734399"></p>
<ul>
<li>即内核中的数据共享</li>
</ul>
</li>
<li><p>NPTL</p>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/eb5b3eaebf114741ae08ba404ec326a1.png" alt="image-20230904091920214"></p>
<p><img src="https://img-blog.csdnimg.cn/d5982a5608ab4a849ea30e24b9890764.png" alt="image-20230904092151610"></p>
</li>
</ul>
</li>
</ul>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul>
<li>线程操作<ul>
<li><img src="https://img-blog.csdnimg.cn/be4565c690a54b8886c3f5af17ce6117.png" alt="image-20230904092816687"></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一般情况下,main函数所在的线程称之为主线程,其他创建的线程称为子线程</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    功能:创建一个子线程</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - thread:传出参数,线程创建成功之后子线程的id</span></span><br><span class="line"><span class="comment">        - attr:设置线程的属性,一般使用默认值NULL</span></span><br><span class="line"><span class="comment">        - start_routine:函数指针,子线程需要处理的逻辑代码</span></span><br><span class="line"><span class="comment">        - arg:给第三个参数使用,传参</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        - 成功返回0</span></span><br><span class="line"><span class="comment">        - 错误返回错误号,与之前的errno不一样</span></span><br><span class="line"><span class="comment">          获取错误号的信息: char* strerror(errno); #include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">    int pthread_create(pthread_t * thread,const pthread_attr_t * attr,</span></span><br><span class="line"><span class="comment">            void *(*start_routine)(void *),void * arg);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个子进程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="终止函数"><a href="#终止函数" class="headerlink" title="终止函数"></a>终止函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    功能:终止一个线程,在哪个线程中调用表示终止哪个线程</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - retval:指针,作为一个返回值,可以在pthread_join()中获取到</span></span><br><span class="line"><span class="comment">    没有返回值</span></span><br><span class="line"><span class="comment">    void pthread_exit(void *retval);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str;</span><br><span class="line">        str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid: %ld, parent thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时,不会影响其他正常运行的线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>); <span class="comment">//不会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//没有执行,进程没有退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="连接已终止的进程"><a href="#连接已终止的进程" class="headerlink" title="连接已终止的进程"></a>连接已终止的进程</h3><ul>
<li><p>该函数的作用是回收子进程资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    功能: 和一个已经终止的线程进行连接。对线程的资源进行释放，回收资源</span></span><br><span class="line"><span class="comment">        这个函数是阻塞函数,调用一次回收一个子线程</span></span><br><span class="line"><span class="comment">        一般在主线程中使用</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        - thread:指定回收的线程号</span></span><br><span class="line"><span class="comment">        - retval:接受子线程退出时的返回值</span></span><br><span class="line"><span class="comment">                 为什么是二级指针:</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回0</span></span><br><span class="line"><span class="comment">        失败返回错误号,非零</span></span><br><span class="line"><span class="comment">    int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = <span class="number">10</span>;  <span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// int tmp = 100; //这里是子进程的栈空间,当该线程结束之后是随机值,</span></span><br><span class="line">    pthread_exit((<span class="type">void</span>*)&amp;value);  <span class="comment">// 等同于return (void*)&amp;tmp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str;</span><br><span class="line">        str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用pthread_join()回收子线程资源</span></span><br><span class="line">    <span class="type">int</span>* thread_retval;</span><br><span class="line">    ret = pthread_join(tid, (<span class="type">void</span>**)&amp;thread_retval);  <span class="comment">// 要回收的子线程没有结束,那么程序阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str;</span><br><span class="line">        str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit data: %d\n&quot;</span>, *thread_retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;回收子线程资源成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid: %ld, parent thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line">    <span class="comment">// 让主线程退出,当至线程退出时,不会影响其他正常运行的线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pthread_join()中二级指针retval的作用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    功能: 和一个已经终止的线程进行连接。对线程的资源进行释放，回收资源</span></span><br><span class="line"><span class="comment">        这个函数是阻塞函数,调用一次回收一个子线程</span></span><br><span class="line"><span class="comment">        一般在主线程中使用</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        - thread:指定回收的线程号</span></span><br><span class="line"><span class="comment">        - retval:接受子线程退出时的返回值</span></span><br><span class="line"><span class="comment">                 为什么是二级指针:</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回0</span></span><br><span class="line"><span class="comment">        失败返回错误号,非零</span></span><br><span class="line"><span class="comment">    int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = <span class="number">10</span>;  <span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="comment">// sleep(3);</span></span><br><span class="line">    <span class="comment">// int tmp = 100; //这里是子进程的栈空间,当该线程结束之后是随机值,</span></span><br><span class="line">    pthread_exit((<span class="type">void</span>*)&amp;value);  <span class="comment">// 等同于return (void*)&amp;tmp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str;</span><br><span class="line">        str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用pthread_join()回收子线程资源</span></span><br><span class="line">    <span class="type">int</span>* thread_retval;</span><br><span class="line">    ret = pthread_join(tid, (<span class="type">void</span>**)&amp;thread_retval);  <span class="comment">// 要回收的子线程没有结束,那么程序阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str;</span><br><span class="line">        str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit data: %d\n&quot;</span>, *thread_retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;回收子线程资源成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid: %ld, parent thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line">    <span class="comment">// 让主线程退出,当至线程退出时,不会影响其他正常运行的线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于二级指针的的理解</p>
<ul>
<li>回到函数返回值和参数都是一级指针。若该参数同样是一级指针，实际上并不能改变回调函数返回值</li>
</ul>
</li>
</ul>
<h3 id="线程的分离"><a href="#线程的分离" class="headerlink" title="线程的分离"></a>线程的分离</h3><ul>
<li>使用pthread_detach函数<ul>
<li>使得线程在结束时候不用再使用pthread_join</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    功能: 分离一个线程,被分离的线程在终止的时候会自动的释放资源返回给系统</span></span><br><span class="line"><span class="comment">          1.不能多次分离,会产生不可预料的行为</span></span><br><span class="line"><span class="comment">          2.不能去连接一个已经分离的线程,会报错</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -thread:需要分离的线程的id</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回0</span></span><br><span class="line"><span class="comment">        失败返回错误号</span></span><br><span class="line"><span class="comment">    int pthread_detach(pthread_t thread);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str;</span><br><span class="line">        str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno1: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid: %ld, main thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程分离,分离后,子线程结束后不需要pthread_join函数回收资源</span></span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str;</span><br><span class="line">        str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno2: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证使用join报错</span></span><br><span class="line">    ret = pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str;</span><br><span class="line">        str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno3: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出主线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><ul>
<li>pthread_cancel</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    功能:取消线程(让线程终止)。</span></span><br><span class="line"><span class="comment">        可以终止某个线程的运行</span></span><br><span class="line"><span class="comment">        但不是立马终止,而是当子线程执行到一个取消点,线程	才会终止</span></span><br><span class="line"><span class="comment">        取消点:系统规定好的一些系统调用,粗略的理解为从用户区到内核区的切换，这个位置称之为取消点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - thread: 要取消的线程的线程号</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_cancel(pthread_t thread);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread tid: %ld\n&quot;</span>, pthread_self()); <span class="comment">// 切换到内核区时执行到取消点，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d\n&quot;</span>, i); <span class="comment">//for循环不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消线程</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ul>
<li><p>相关函数</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/613898f31310484ebcb815f94a3d97f3.png" alt="image-20230904201835479"></li>
<li><img src="https://img-blog.csdnimg.cn/381eee70982849c68732dc0847a6e5a4.png" alt="image-20230904201931971"></li>
</ul>
</li>
<li><p>使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_attr_init(pthread_attr_t *attr);</span></span><br><span class="line"><span class="comment">        -初始化属性变量</span></span><br><span class="line"><span class="comment">    int pthread_attr_destroy(pthread_attr_t *attr);</span></span><br><span class="line"><span class="comment">        -释放线程属性资源</span></span><br><span class="line"><span class="comment">    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</span></span><br><span class="line"><span class="comment">        -设置线程分离的状态属性</span></span><br><span class="line"><span class="comment">    int pthread_attr_getdetachstate(const pthread_attr_t *attr,int *detachstate);</span></span><br><span class="line"><span class="comment">        -获取线程分离的状态属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread tid: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程属性变量</span></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="comment">// 初始化线程属性</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, &amp;attr, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* str;</span><br><span class="line">        str = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno1: %s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程栈的大小</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    pthread_attr_getstacksize(&amp;attr, &amp;size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread stack size:%ld\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid: %ld, main thread id: %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放线程属性资源</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出主线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li>概念</li>
<li><img src="https://img-blog.csdnimg.cn/d91e3c9d74514c8288be8603237b2f88.png" alt="image-20230904210756882"><ul>
<li><strong>线程同步效率低，但是必要的</strong></li>
</ul>
</li>
</ul>
<h4 id="互斥锁mutex"><a href="#互斥锁mutex" class="headerlink" title="互斥锁mutex"></a>互斥锁mutex</h4><ul>
<li><p><img src="https://img-blog.csdnimg.cn/01b931b768914012a1e4218800fc5c8d.png" alt="image-20230904211339210"></p>
<ul>
<li>互斥量的两种状态<ul>
<li>已锁定locked</li>
<li>未送定unlocked</li>
</ul>
</li>
</ul>
</li>
<li><p>只有一个线程能够持有该互斥量，其他线程将遭到阻塞</p>
<p><img src="https://img-blog.csdnimg.cn/f3f3e0d5512445708d031b4d953f9078.png" alt="image-20230904212201904"></p>
</li>
<li><p>互斥量相关操作函数</p>
<ul>
<li>见下面代码注释中</li>
</ul>
</li>
<li><p>售票系统案例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用多线程实现买票</span></span><br><span class="line"><span class="comment">    3个窗口,共100张票</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        互斥量的类型 pthread_mutex_t</span></span><br><span class="line"><span class="comment">    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">        - 初始化互斥量</span></span><br><span class="line"><span class="comment">        - 参数 ：</span></span><br><span class="line"><span class="comment">            - mutex ： 需要初始化的互斥量变量</span></span><br><span class="line"><span class="comment">            - attr ： 互斥量相关的属性，NULL</span></span><br><span class="line"><span class="comment">        - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。</span></span><br><span class="line"><span class="comment">            pthread_mutex_t *restrict mutex = xxx;</span></span><br><span class="line"><span class="comment">            pthread_mutex_t * mutex1 = mutex;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_destroy(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 释放互斥量的资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_lock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_trylock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_unlock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 解锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享门票,全局变量</span></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量,要求是全局变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">sellticket</span><span class="params">(<span class="type">void</span>* argv)</span> &#123;</span><br><span class="line">    <span class="comment">//  卖票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 对共享数据的操作,加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化互斥量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2, tid3;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程资源</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程分离</span></span><br><span class="line">    <span class="comment">// pthread_detach(tid1);</span></span><br><span class="line">    <span class="comment">// pthread_detach(tid2);</span></span><br><span class="line">    <span class="comment">// pthread_detach(tid3);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥量资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出主线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul>
<li><img src="https://img-blog.csdnimg.cn/3fd4ff7d06f54569adee705ac4eff84c.png" alt="image-20230904214402239"></li>
<li>产生死锁的场景<ul>
<li>忘记释放锁</li>
<li>重复加锁</li>
<li>多线程多锁，抢占锁资源<ul>
<li>一个进程访问多个临界资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul>
<li><p>一个线程已经持有互斥锁，但是当前线程只是需要读取共享资源，可以赋予其读写锁</p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/a6f9018fb8464a64817eb24d55e5868f.png" alt="image-20230905184905556"></p>
</li>
<li><p>读写锁的特点</p>
<ul>
<li>如果有线程读数据，则允许其他线程数据读，不允许写</li>
<li>如果有线程写数据，则其他线程读写操作都不允许</li>
<li>写操作是独占的，写的优先级更高</li>
</ul>
</li>
<li><p>相关的读写锁操作函数</p>
<p><img src="https://img-blog.csdnimg.cn/869dec597a9341e89b0a8477fe338485.png" alt="image-20230905185626512"></p>
</li>
<li><p>虽然互斥锁也能解决读写问题，但是效率很低，使用读写锁能极大的提高效率</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 案例:创建8个线程, 操作同一个全局变量</span></span><br><span class="line"><span class="comment">// 3个线程不定时写这个全局,5个线程不定时读这个全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享数据</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建读写锁</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span>* argv)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write++, tid: %ld, num: %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span>* argv)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===read, tid: %ld, num: %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个写线程，5个读线程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtids[<span class="number">3</span>], rtids[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;wtids[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;rtids[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程分离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        pthread_detach(wtids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(rtids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出主线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><ul>
<li>三要素<ul>
<li>生产者</li>
<li>消费者</li>
<li>容器</li>
</ul>
</li>
<li>当容器装满<ul>
<li>生产者进程阻塞</li>
</ul>
</li>
<li>当容器空<ul>
<li>消费者进程阻塞</li>
</ul>
</li>
</ul>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><ul>
<li><img src="https://img-blog.csdnimg.cn/e69e33f90f624c07a53eeb21fcdf547e.png" alt="image-20230905211311914"><ul>
<li>满足某个条件执行操作</li>
</ul>
</li>
<li>生产者消费者和条件变量的示例</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者消费者模型</span></span><br><span class="line"><span class="comment">    使用了条件变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表当做容器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num: %d, tid: %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        <span class="comment">// 只要生产了一个,就通知消费者消费</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">customer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 判断是否有数据</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 容器空了,阻塞</span></span><br><span class="line">            <span class="comment">// 当wait函数调用阻塞时会解锁,释放mutex,当不阻塞时,继续向下执行时会重新加锁</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">struct</span> Node* tmp = head;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;delete node, num: %d, tid: %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建5个生产者线程和5个消费者线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(&amp;ptids[i]);</span><br><span class="line">        pthread_detach(&amp;ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ul>
<li><p>信号量的类型 sem_t</p>
<p><img src="https://img-blog.csdnimg.cn/c370693fae7a45a78e1e10511458d4e1.png" alt="image-20230905214142063"></p>
<ul>
<li>阻塞线程，不能保证线程安全</li>
</ul>
</li>
<li><p>信号量的使用</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    信号量的类型 sem_t</span></span><br><span class="line"><span class="comment">    int sem_init(sem_t *sem, int pshared, unsigned int value);</span></span><br><span class="line"><span class="comment">        - 初始化信号量</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - sem : 信号量变量的地址</span></span><br><span class="line"><span class="comment">            - pshared : 0 用在线程间 ，非0 用在进程间</span></span><br><span class="line"><span class="comment">            - value : 信号量中的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_destroy(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 释放资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_wait(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_trywait(sem_t *sem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span></span><br><span class="line"><span class="comment">    int sem_post(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 对信号量解锁，调用一次对信号量的值+1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_getvalue(sem_t *sem, int *sval);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    sem_t psem;</span></span><br><span class="line"><span class="comment">    sem_t csem;</span></span><br><span class="line"><span class="comment">    init(psem, 0, 8);</span></span><br><span class="line"><span class="comment">    init(csem, 0, 0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    producer() &#123;</span></span><br><span class="line"><span class="comment">        sem_wait(&amp;psem);</span></span><br><span class="line"><span class="comment">        sem_post(&amp;csem)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    customer() &#123;</span></span><br><span class="line"><span class="comment">        sem_wait(&amp;csem);</span></span><br><span class="line"><span class="comment">        sem_post(&amp;psem)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建两个信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">producer</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">customer</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络结构模式"><a href="#网络结构模式" class="headerlink" title="网络结构模式"></a>网络结构模式</h3><h4 id="C-S结构"><a href="#C-S结构" class="headerlink" title="C&#x2F;S结构"></a>C&#x2F;S结构</h4><hr>
<blockquote>
<p>服务器 - 客户机，即 Client - Server（C&#x2F;S）结构。C&#x2F;S 结构通常采取两层结构。服务器负责数据的</p>
<p>管理，客户机负责完成与用户的交互任务。客户机是因特网上访问别人信息的机器，服务器则是提</p>
<p>供信息供人访问的计算机。</p>
<p>客户机通过局域网与服务器相连，接受用户的请求，并通过网络向服务器提出请求，对数据库进行</p>
<p>操作。服务器接受客户机的请求，将数据提交给客户机，客户机将数据进行计算并将结果呈现给用</p>
<p>户。服务器还要提供完善安全保护及对数据完整性的处理等操作，并允许多个客户机同时访问服务</p>
<p>器，这就对服务器的硬件处理数据能力提出了很高的要求。</p>
<p>在C&#x2F;S结构中，应用程序分为两部分：服务器部分和客户机部分。服务器部分是多个用户共享的信</p>
<p>息与功能，执行后台服务，如控制共享数据库的操作等；客户机部分为用户所专有，负责执行前台</p>
<p>功能，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。</p>
</blockquote>
<ul>
<li><p>优点</p>
<ol>
<li>能充分发挥客户端 PC 的处理能力，很多工作可以在客户端处理后再提交给服务器，所以 C&#x2F;S 结构</li>
</ol>
<p>客户端响应速度快；</p>
<ol start="2">
<li>操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求；</li>
<li>C&#x2F;S 结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程；</li>
<li>安全性较高，C&#x2F;S 一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校</li>
</ol>
<p>验，提供了更安全的存取模式，对信息安全的控制能力很强，一般高度机密的信息系统采用 C&#x2F;S 结</p>
<p>构适宜</p>
</li>
<li><p>缺点</p>
<ol>
<li>客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病</li>
</ol>
<p>毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和</p>
<p>升级成本非常高；</p>
<ol start="2">
<li>对客户端的操作系统一般也会有限制，不能够跨平台。</li>
</ol>
</li>
</ul>
<h4 id="B-S结构"><a href="#B-S结构" class="headerlink" title="B&#x2F;S结构"></a>B&#x2F;S结构</h4><blockquote>
<p>B&#x2F;S 结构（Browser&#x2F;Server，浏览器&#x2F;服务器模式），是 WEB 兴起后的一种网络结构模式，WEB</p>
<p>浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服</p>
<p>务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如 Firefox 或 Internet</p>
<p>Explorer，服务器安装 SQL Server、Oracle、MySQL 等数据库。浏览器通过 Web Server 同数据</p>
<p>库进行数据交互。</p>
</blockquote>
<ul>
<li><p>优点</p>
<p>B&#x2F;S 架构最大的优点是总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软</p>
<p>件就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能</p>
<p>使用。</p>
</li>
<li><p>缺点</p>
<ol>
<li>通信开销大、系统和数据的安全性较难保障; </li>
<li>个性特点明显降低，无法实现具有个性化的功能要求；</li>
<li>协议一般是固定的：http&#x2F;https</li>
<li>客户端服务器端的交互是请求-响应模式，通常动态刷新页面，响应速度明显降低。</li>
</ol>
</li>
</ul>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><blockquote>
<p>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网</p>
<p>络接口卡NIC。其<strong>拥有 MAC 地址</strong>，属于 OSI 模型的第 2 层，它使得用户可以通过电缆或无线相互</p>
<p>连接。<strong>每一个网卡都有一个被称为 MAC 地址的独一无二的 48 位串行号</strong>。网卡的主要功能：1.数</p>
<p>据的封装与解封装、2.链路管理、3.数据编码与译码。</p>
</blockquote>
<hr>
<ul>
<li>MAC地址</li>
</ul>
<blockquote>
<p>MAC 地址（Media Access Control Address），直译为媒体存取控制位址，也称为<strong>局域网地址、</strong></p>
<p><strong>以太网地址、物理地址或硬件地址</strong>，它是一个用来确认网络设备位置的位址，由网络设备制造商生</p>
<p>产时烧录在网卡中（固定死）。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC</p>
<p>位址 。<strong>MAC 地址用于在网络中唯一标识一个网卡</strong>，一台设备若有一或多个网卡，则每个网卡都需</p>
<p>要并会有一个唯一的 MAC 地址。(比如说我的笔记本有以太网卡和无线网卡，两个网卡的MAC地址不同)</p>
<p>MAC 地址的长度为 48 位（6个字节），通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就是一个MAC 地址，其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由IEEE（电气与电子工程师协会）分配，而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的某个网络产品（如网卡）的系列号。<strong>只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。</strong></p>
<p>形象地说，MAC 地址就如同身份证上的身份证号码，具有唯一性。</p>
</blockquote>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><blockquote>
<p><strong>IP 协议</strong>是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所</p>
<p>有计算机网络<strong>实现相互通信的一套规则</strong>，规定了计算机在因特网上进行通信时应当遵守的规则。任</p>
<p>何厂家生产的计算机系统，只要遵守 IP 协议就可以与因特网互连互通。各个厂家生产的网络系统</p>
<p>和设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传</p>
<p>送数据的基本单元（技术上称之为“帧”）的格式不同。IP 协议实际上是一套由软件程序组成的协议</p>
<p>软件，<strong>它把各种不同“帧”统一转换成“IP 数据报”格式</strong>，这种转换是因特网的一个最重要的特点，使</p>
<p>所有各种计算机都能在因特网上实现互通，即具有“开放性”的特点。正是因为有了 IP 协议，因特</p>
<p>网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP 协议也可以叫做“因特网</p>
<p>协议”。</p>
<p>IP 地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址。IP 地址是 IP</p>
<p>协议提供的一种<strong>统一的地址格式</strong>，它为互联网上的每一个网络和每一台主机分配一个<strong>逻辑地址</strong>，<strong>以</strong></p>
<p><strong>此来屏蔽物理地址的差异。</strong></p>
<p>IPv4地址是一个 32 位的二进制数，通常被分割为 4 个“ 8 位二进制数”（也就是 4 个字节）。IP 地址</p>
<p>通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是 0~255 之间的十进制整数。</p>
<p>例：点分十进IP地址（100.4.5.6），实际上是 32 位二进制数</p>
<p>（01100100.00000100.00000101.00000110）。</p>
</blockquote>
<h4 id="IP地址编址方式"><a href="#IP地址编址方式" class="headerlink" title="IP地址编址方式"></a>IP地址编址方式</h4><blockquote>
<p>最初设计互联网络时，为了便于寻址以及层次化构造网络，每个 IP 地址包括两个标识码（ID），即网络</p>
<p>ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工</p>
<p>作站，服务器和路由器等）有一个主机 ID 与其对应。Internet 委员会定义了 5 种 IP 地址类型以适合不</p>
<p>同容量的网络，即 A 类~ E 类。</p>
<p>其中 A、B、C 3类（如下表格）由 InternetNIC 在全球范围内统一分配，D、E 类为特殊地址。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/58a9f8ced77e4644ba57ce81ce94e2de.png" alt="image-20230906094959196"></p>
<ul>
<li>A类IP地址</li>
</ul>
<blockquote>
<pre><code>     一个 A 类 IP 地址是指， 在 IP 地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算

 机的号码。如果用二进制表示 IP 地址的话，A 类 IP 地址就由 1 字节的网络地址和 3 字节主机地址组

 成，**网络地址的最高位必须是“0”**。A 类 IP 地址中网络的标识长度为 8 位，主机标识的长度为 24 位，A

 类网络地址数量较少，有 126 个网络，每个网络可以容纳主机数达 1600 多万台。

 A 类 IP 地址 地址范围 1.0.0.1 - 126.255.255.254（二进制表示为：00000001 00000000 00000000

 00000001 - 01111111 11111111 11111111 11111110）。最后一个是广播地址(全1)。

 A 类 IP 地址的子网掩码为 255.0.0.0，每个网络支持的最大主机数为 256 的 3 次方 - 2 = 16777214 台。
</code></pre>
</blockquote>
<ul>
<li>B 类IP地址</li>
</ul>
<blockquote>
<p>一个 B 类 IP 地址是指，在 IP 地址的四段号码中，前两段号码为网络号码。如果用二进制表示 IP 地址的</p>
<p>话，B 类 IP 地址就由 2 字节的网络地址和 2 字节主机地址组成，<strong>网络地址的最高位必须是“10”</strong>。B 类 IP</p>
<p>地址中网络的标识长度为 16 位，主机标识的长度为 16 位，B 类网络地址适用于中等规模的网络，有</p>
<p>16384 个网络，每个网络所能容纳的计算机数为 6 万多台。</p>
<p>B 类 IP 地址地址范围 128.0.0.1 - 191.255.255.254 （二进制表示为：10000000 00000000 00000000</p>
<p>00000001 - 10111111 11111111 11111111 11111110）。 最后一个是广播地址。</p>
<p>B 类 IP 地址的子网掩码为 255.255.0.0，每个网络支持的最大主机数为 256 的 2 次方 - 2 &#x3D; 65534 台</p>
</blockquote>
<ul>
<li>C 类IP地址</li>
</ul>
<blockquote>
<p>一个 C 类 IP 地址是指，在 IP 地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算</p>
<p>机的号码。如果用二进制表示 IP 地址的话，C 类 IP 地址就由 3 字节的网络地址和 1 字节主机地址组</p>
<p>成，<strong>网络地址的最高位必须是“110”</strong>。C 类 IP 地址中网络的标识长度为 24 位，主机标识的长度为 8 位，</p>
<p>C 类网络地址数量较多，有 209 万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台</p>
<p>计算机。</p>
<p>C 类 IP 地址范围 192.0.0.1-223.255.255.254 （二进制表示为: 11000000 00000000 00000000</p>
<p>00000001 - 11011111 11111111 11111111 11111110）。</p>
<p>C类IP地址的子网掩码为 255.255.255.0，每个网络支持的最大主机数为 256 - 2 &#x3D; 254 台。</p>
</blockquote>
<ul>
<li>特殊的网址</li>
</ul>
<blockquote>
<p>每一个字节都为 0 的地址（ “0.0.0.0” ）对应于<strong>当前主机</strong>；</p>
<p>IP 地址中的每一个字节都为 1 的 IP 地址（ “255.255.255.255” ）是当前子网的<strong>广播地址</strong>；</p>
<p>IP 地址中凡是以 “11110” 开头的 <strong>E 类 IP 地址都保留用于将来和实验使用。</strong></p>
<p>IP地址中<strong>不能以十进制 “127”</strong> 作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测</p>
<p>试，如：127.0.0.1可以代表本机IP地址。</p>
</blockquote>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><blockquote>
<p>子网掩码（subnet mask）又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个 IP 地</p>
<p>址的<strong>哪些位标识的是主机所在的子网</strong>，以及哪些位标识的是<strong>主机的位掩码</strong>。子网掩码不能单独存</p>
<p>在，它<strong>必须结合 IP 地址一起使用。</strong>子网掩码只有一个作用，就是将某个 IP 地址划分成网络地址和</p>
<p>主机地址两部分。</p>
<p>子网掩码是一个 32 位地址，用于屏蔽 IP 地址的一部分以区别网络标识和主机标识，并说明该 IP</p>
<p>地址是在局域网上，还是在广域网上</p>
</blockquote>
<ul>
<li><p>子网掩码是在 IPv4 地址资源紧缺的背景下为了解决 lP 地址分配而产生的虚拟 lP 技术，通过子网掩码将</p>
<p>A、B、C 三类地址划分为若干子网，从而显著提高了 IP 地址的分配效率，有效解决了 IP 地址资源紧张</p>
<p>的局面。另一方面，在企业内网中为了更好地管理网络，网管人员也利用子网掩码的作用，人为地将一</p>
<p>个较大的企业内部网络划分为更多个小规模的子网，再利用三层交换机的路由功能实现子网互联，从而</p>
<p>有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。在大多数的网络教科书中，一般都将子网掩码的作用描述为通过逻辑运算，将 IP 地址划分为网络标识</p>
<p>(Net.ID) 和主机标识(Host.ID)，只有网络标识相同的两台主机在无路由的情况下才能相互通信。</p>
<p>根据 RFC950 定义，子网掩码是一个 32 位的 2 进制数， 其对应网络地址的所有位都置为 1，对应于主</p>
<p>机地址的所有位置都为 0。子网掩码告知路由器，地址的哪一部分是网络地址，哪一部分是主机地址，</p>
<p>使路由器正确判断任意 IP 地址是否是本网段的，从而正确地进行路由。网络上，数据从一个地方传到另</p>
<p>外一个地方，是依靠 IP 寻址。从逻辑上来讲，是两步的。第一步，从 IP 中找到所属的网络，好比是去</p>
<p>找这个人是哪个小区的；第二步，再从 IP 中找到主机在这个网络中的位置，好比是在小区里面找到这个</p>
<p>人。</p>
<p>子网掩码的设定必须遵循一定的规则。与二进制 IP 地址相同，子网掩码由 1 和 0 组成，且 1 和 0 分别</p>
<p>连续。子网掩码的长度也是 32 位，左边是网络位，用二进制数字 “1” 表示，1 的数目等于网络位的长</p>
<p>度；右边是主机位，用二进制数字 “0” 表示，0 的数目等于主机位的长度。这样做的目的是为了让掩码</p>
<p>与 IP 地址做按位与运算时用 0 遮住原主机数，而不改变原网络段数字，而且很容易通过 0 的位数确定子</p>
<p>网的主机数（ 2 的主机位数次方 - 2，因为主机号全为 1 时表示该网络广播地址，全为 0 时表示该网络</p>
<p>的网络号，这是两个特殊地址）。通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使</p>
<p>网络正常工作。</p>
</li>
</ul>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><ul>
<li><strong>标记计算机中进程的唯一编号</strong></li>
</ul>
<blockquote>
<p>“端口” 是英文 port 的意译，可以认为是<strong>设备与外界通讯交流的出口</strong>。端口可分为虚拟端口和物理</p>
<p>端口，其中<strong>虚拟端口指计算机内部或交换机路由器内的端口，不可见</strong>，是特指TCP&#x2F;IP协议中的端</p>
<p>口，是逻辑意义上的端口。例如计算机中的 80 端口、21 端口、23 端口等。物理端口又称为接</p>
<p>口，是可见端口，计算机背板的 RJ45 网口，交换机路由器集线器等 RJ45 端口。电话使用 RJ11 插</p>
<p>口也属于物理端口的范畴。</p>
<p>如果把 IP 地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个 IP</p>
<p>地址的端口可以有 65536（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数，</p>
<p>范围是从 0 到65535（2^16-1）。</p>
</blockquote>
<ul>
<li><p>端口类型</p>
<p>​	1.<strong>周知端口</strong>（Well Known Ports）</p>
<p>周知端口是众所周知的端口号，也叫知名端口、公认端口或者常用端口，<strong>范围从 0 到 1023</strong>，它们紧密</p>
<p>绑定于一些特定的服务。例如 80 端口分配给 WWW 服务，21 端口分配给 FTP 服务，23 端口分配给</p>
<p>Telnet服务等等。我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下</p>
<p>WWW 服务的端口是 “80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏</p>
<p>上指定端口号，方法是在地址后面加上冒号“:”（半角），再加上端口号。比如使用 “8080” 作为 WWW</p>
<p>服务的端口，则需要在地址栏里输入“网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改</p>
<p>变的，比如 139 端口专门用于 NetBIOS 与 TCP&#x2F;IP 之间的通信，不能手动改变。</p>
<p>​	2.<strong>注册端口</strong>（Registered Ports）</p>
<p>端口号从 1024 到 49151，它们松散地绑定于一些服务，分配给用户进程或应用程序，这些进程主要是</p>
<p>用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资</p>
<p>源占用的时候，可以用用户端动态选用为源端口。</p>
<p>​	3.<strong>动态端口 &#x2F; 私有端口</strong>（Dynamic Ports &#x2F; Private Ports）</p>
<p>动态端口的范围是从 49152 到 65535。之所以称为动态端口，是因为它一般不固定分配某种服务，而是</p>
<p>动态分配。</p>
</li>
</ul>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><ul>
<li><p>OSI七层模型</p>
<blockquote>
<p>七层模型，亦称 OSI（Open System Interconnection）参考模型，即开放式系统互联。参考模型</p>
<p>是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为 OSI 参</p>
<p>考模型或七层模型。</p>
<p>它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/a9bd4b850ea64d4c9439f618b08f8122.png" alt="image-20230906140957373"></p>
<ol>
<li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率</li>
</ol>
<p>等。它的主要作用是<strong>传输比特流</strong>（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为</p>
<p>1、0，也就是我们常说的<strong>数模转换与模数转换</strong>）。这一层的数据叫做比特。</p>
<ol start="2">
<li>数据链路层：建立<strong>逻辑连接</strong>、进行<strong>硬件地址寻址</strong>、<strong>差错校验等</strong>功能。定义了如何让格式化数据<strong>以帧</strong></li>
</ol>
<p><strong>为单位进行传输</strong>，以及如何让控制对物理介质的访问。将比特组合成字节进而组合成帧，用MAC地</p>
<p>址访问介质。</p>
<ol start="3">
<li>网络层：进行<strong>逻辑地址寻址</strong>，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选</li>
</ol>
<p>择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的</p>
<p>层。</p>
<ol start="4">
<li>传输层：定义了一些传输数据的<strong>协议和端口号</strong>（ WWW 端口 80 等），如：<strong>TCP</strong>（传输控制协议，</li>
</ol>
<p>传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），<strong>UDP</strong>（用户数据报协议，与</p>
<p>TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方</p>
<p>式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这</p>
<p>一层数据叫做段。</p>
<ol start="5">
<li>会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间</li>
</ol>
<p>发起会话或者接受会话请求。保存了连接信息，下次再次通信时不需要从底层重新寻找</p>
<ol start="6">
<li>表示层：数据的表示、安全、压缩。主要是进行对接收的数据进行解释、加密与解密、压缩与解压</li>
</ol>
<p>缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。</p>
<ol start="7">
<li>应用层：<strong>网络服务与最终用户的一个接口</strong>。这一层为用户的应用程序（例如电子邮件、文件传输和</li>
</ol>
<p>终端仿真）提供网络服务。</p>
</li>
<li><p>OSI七层模型</p>
</li>
</ul>
<blockquote>
<p>现在 Internet（因特网）使用的主流协议族是 TCP&#x2F;IP 协议族，它是一个分层、多协议的通信体</p>
<p>系。TCP&#x2F;IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用</p>
<p>层。每一层完成不同的功能，且通过若干协议来实现，<strong>上层协议使用下层协议提供的服务</strong></p>
</blockquote>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/58e65937a24c4980afc35fbb03dd7a39.png" alt="image-20230906201217745"></p>
</li>
<li><p>TCP&#x2F;IP 协议在一定程度上参考了 OSI 的体系结构。OSI 模型共有七层，从下到上分别是物理层、数据链</p>
<p>路层、网络层、传输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在 TCP&#x2F;IP 协议中，</p>
<p>它们被简化为了四个层次。</p>
<p>（1）应用层、表示层、会话层三个层次提供的服务相差不是很大，所以在 TCP&#x2F;IP 协议中，它们被合并</p>
<p>为应用层一个层次。</p>
<p>（2）由于传输层和网络层在网络协议中的地位十分重要，所以在 TCP&#x2F;IP 协议中它们被作为独立的两个</p>
<p>层次。</p>
<p>（3）因为数据链路层和物理层的内容相差不多，所以在 TCP&#x2F;IP 协议中它们被归并在网络接口层一个层</p>
<p>次里。只有四层体系结构的 TCP&#x2F;IP 协议，与有七层体系结构的 OSI 相比要简单了不少，也正是这样，</p>
<p>TCP&#x2F;IP 协议在实际的应用中效率更高，成本更低。</p>
<p><img src="https://img-blog.csdnimg.cn/294be6eb65eb4beab8dcfcbf545a4bad.png" alt="image-20230906201507452"></p>
</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><blockquote>
<p>协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连</p>
<p>接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：<strong>语</strong></p>
<p><strong>法、语义、时序</strong>。</p>
<p>为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议</p>
<p>（protocol），它<strong>最终体现为在网络上传输的数据包的格式</strong>。</p>
<p>协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议</p>
</blockquote>
<ul>
<li><p>语法：什么操作</p>
</li>
<li><p>语义：什么意思</p>
</li>
<li><p>时序(同步)：顺序</p>
</li>
<li><p>常见的协议</p>
<blockquote>
<p>应用层常见的协议有：<strong>FTP协议</strong>（File Transfer Protocol 文件传输协议）、<strong>HTTP协议</strong>（Hyper Text</p>
<p>Transfer Protocol 超文本传输协议）、NFS（Network File System 网络文件系统）。</p>
<p>传输层常见协议有：<strong>TCP协议</strong>（Transmission Control Protocol 传输控制协议）、<strong>UDP协议</strong>（User</p>
<p>Datagram Protocol 用户数据报协议）。</p>
<p>网络层常见协议有：<strong>IP 协议</strong>（Internet Protocol 因特网互联协议）、<strong>ICMP 协议</strong>（Internet Control Message Protocol 因特网控制报文协议）、IGMP 协议（Internet Group Management Protocol 因特</p>
<p>网组管理协议）。</p>
<p>网络接口层常见协议有：<strong>ARP协议（</strong>Address Resolution Protocol 地址解析协议）、RARP协议</p>
<p>（Reverse Address Resolution Protocol 反向地址解析协议）</p>
</blockquote>
</li>
</ul>
<h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p><img src="https://img-blog.csdnimg.cn/7b014bc804ec46639518b6d7caae97eb.png" alt="image-20230906204136771"></p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p><img src="https://img-blog.csdnimg.cn/066b769a74f94aaaa0fd493b21a0f30c.png" alt="image-20230906204227880"></p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p><img src="https://img-blog.csdnimg.cn/83f3f3726f644c9bb426fa55ebfa7839.png" alt="image-20230906204435031"></p>
<h4 id="以太网帧协议"><a href="#以太网帧协议" class="headerlink" title="以太网帧协议"></a>以太网帧协议</h4><p><img src="https://img-blog.csdnimg.cn/1cf94a580719480e83f6c5e14c1738d5.png" alt="image-20230906205038870"></p>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p><img src="https://img-blog.csdnimg.cn/57f1d8f0548e4bcc988b8f3f1fa33414.png" alt="image-20230906205054358"></p>
<h3 id="网络通信过程"><a href="#网络通信过程" class="headerlink" title="网络通信过程"></a>网络通信过程</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><blockquote>
<p>上层协议是如何使用下层协议提供的服务的呢？其实这是通过<strong>封装（encapsulation）</strong>实现的。应用程序</p>
<p>数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将<strong>在上层数据的基础上加</strong></p>
<p><strong>上自己的头部信息</strong>（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。</p>
</blockquote>
<ul>
<li><p>什么是封装</p>
<p><img src="https://img-blog.csdnimg.cn/6dccfcf2e87046679335e9db87cb7a42.png" alt="image-20230906210915197"></p>
</li>
</ul>
<h4 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h4><blockquote>
<p><strong>当帧到达目的主机时，将沿着协议栈自底向上依次传递</strong>。各层协议依次处理帧中本层负责的头部数据，</p>
<p>以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为<strong>分用</strong>（demultiplexing）。</p>
<p>分用是依靠头部信息中的类型字段实现的。</p>
</blockquote>
<ul>
<li><p>通信示意图</p>
<p><img src="https://img-blog.csdnimg.cn/76312c00098f43d58d509bc615136d86.png" alt="image-20230906213049487"></p>
<ul>
<li>怎么根据IP地址查找MAC地址？<ul>
<li><strong>ARP协议</strong><ul>
<li>通过IP地址查找MAC地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ARP协议示意</p>
<p><img src="https://img-blog.csdnimg.cn/59925cc609f34c84867832237d20cfdf.png" alt="image-20230906214600378"></p>
</li>
<li><p>ARP请求包</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/e979997d69994f77bfb1c87e8ebac65b.png" alt="image-20230906214710955"></p>
<ul>
<li>响应时因为知道目的端的MAC地址，直接传送，不需要广播<ul>
<li>注意ARP报文端有些需要改变</li>
</ul>
</li>
</ul>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><ul>
<li>一系列的接口</li>
</ul>
<blockquote>
<p>所谓 socket（套接字），就是<strong>对网络中不同主机上的应用进程之间进行双向通信的端点的抽象</strong>。</p>
<p>一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处</p>
<p>的地位来讲，<strong>套接字上联应用进程，下联网络协议栈</strong>，是应用程序通过网络协议进行通信的接口，</p>
<p>是应用程序与网络协议进行交互的接口。</p>
<p>socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概</p>
<p>念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接</p>
<p>字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在</p>
<p>主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台</p>
<p>主机的 socket 中，使对方能够接收到这段信息。<strong>socket 是由 IP 地址和端口结合的</strong>，提供向应用</p>
<p>层进程传送数据包的机制。</p>
<p>socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。<strong>本质为</strong></p>
<p><strong>内核借助缓冲区形成的伪文件</strong>。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接</p>
<p>字。与管道类似的，<strong>Linux 系统将其封装成文件的目的是为了统一接口</strong>，使得读写套接字和读写文</p>
<p>件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传</p>
<p>递。</p>
</blockquote>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/d6c934841e37471a9f42f9ec6815e605.png" alt="image-20230906223159019"></p>
</li>
<li><p>套接字通信分为两部分</p>
<ul>
<li>服务器端<ul>
<li>被动接受客户端连接</li>
</ul>
</li>
<li>客户端<ul>
<li>主动向服务器端发起连接</li>
</ul>
</li>
</ul>
</li>
<li><p>socket是一套通信的接口，Linux和windows都有，有一些细微的差别</p>
</li>
</ul>
<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><ul>
<li>简介：</li>
</ul>
<blockquote>
<p>现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4</p>
<p>字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机</p>
<p>体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问</p>
<p>题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如</p>
<p>套接字通信分两部分： </p>
<p>- 服务器端：被动接受连接，一般不会主动发起连接 </p>
<p>- 客户端：主动向服务器发起连接 </p>
<p>socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别。果不达成一致的规则，通信双方将无法进行正确的编码&#x2F;译码从而导致通信失败。</p>
<p><strong>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数</strong></p>
<p><strong>据当然就无需谈顺序的问题了)。</strong></p>
<p>字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整</p>
<p>数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地</p>
<p>址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地</p>
<p>址处。</p>
</blockquote>
<ul>
<li><p>举例</p>
<ul>
<li><p>小端字节序</p>
<p><img src="https://img-blog.csdnimg.cn/abfdcd0619ae40bdb8b944b7ac9db896.png" alt="image-20230907125254993"></p>
</li>
<li><p>大端字节序</p>
<p><img src="https://img-blog.csdnimg.cn/f501a1a24a034bbbbde3f1ad6147a638.png" alt="image-20230907125308343"></p>
</li>
</ul>
</li>
<li><p>计算机一般采用的是小端字节序</p>
</li>
<li><p>测试自己计算机的字节序</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字节序:字节在内存中存储的顺序</span></span><br><span class="line"><span class="comment">    小端字节序: 数据的高位字节存储在内存的高位地址，低位字节存储在内存的低位地址</span></span><br><span class="line"><span class="comment">    大端字节序: 数据的低位字节存储在内存的高位地址，高位字节存储在内存的低位地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过代码检测当前主机的字节序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">short</span> value;                <span class="comment">// 2B</span></span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];  <span class="comment">// 2B</span></span><br><span class="line">    &#125; test;</span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span> (test.bytes[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; test.bytes[<span class="number">1</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (test.bytes[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; test.bytes[<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h4><blockquote>
<p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：<strong>发送端总是把要发送的数据转换成大端字节序数据后再发送</strong>，<strong>而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换</strong>（小端机转换，大端机不转换）。<strong>协议族</strong> <strong>地址族</strong> <strong>描述</strong></p>
<p>PF_UNIX AF_UNIX UNIX本地域协议族PF_INET、AF_INET、TCP&#x2F;IPv4协议族、PF_INET6、AF_INET6 、TCP&#x2F;IPv6协议族</p>
<p><strong>网络字节顺序</strong>是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p>
</blockquote>
<ul>
<li>规定<strong>网络字节序都是大端</strong>，主机字节序视自己计算机情况而定</li>
</ul>
<blockquote>
<p>网络通信时，需要将主机字节序转换成<strong>网络字节序(大端)</strong></p>
<p>另一段获取到数据之后根据情况将网络字节序转换成主机字节序</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h - host 主机，主机字节序 </span><br><span class="line">to - 转换成什么 </span><br><span class="line">n - network 网络字节序 </span><br><span class="line">s - short unsigned short </span><br><span class="line">l - long unsigned int</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="comment">// 转换端口 </span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序 - 网络字节序 </span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序 - 主机字节序 </span></span><br><span class="line"><span class="comment">// 转IP </span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序 - 网络字节序 </span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// 网络字节序 - 主机字节序 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>区别：数据类型不一样。<strong>short类型适合用于端口的转换，long类型适合用于IP的转换</strong></p>
</li>
<li><p>四个函数的使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 转换端口</span></span><br><span class="line"><span class="comment">    uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="comment">    uint16_t ntohs(uint16_t netshort); // 网络字节序 - 主机字节序 </span></span><br><span class="line"><span class="comment">    // 转IP</span></span><br><span class="line"><span class="comment">    uint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="comment">    uint32_t ntohl(uint32_t netlong); // 网络字节序 - 主机字节序 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// htons</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;  <span class="comment">// 2字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a: %x\n&quot;</span>, a);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b = htons(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: %x\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;===============\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// htonl 转IP</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>] = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)buf;  <span class="comment">// 转换成int* 取的时候是读取四个字节</span></span><br><span class="line">    <span class="type">int</span> sum = htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = (<span class="type">char</span>*)&amp;sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p + <span class="number">1</span>), *(p + <span class="number">2</span>), *(p + <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;===============\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ntohl</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">168</span>, <span class="number">192</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num1 = *(<span class="type">int</span>*)buf1;</span><br><span class="line">    <span class="type">int</span> sum1 = ntohl(num1);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p1 = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;sum1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p1, *(p1 + <span class="number">1</span>), *(p1 + <span class="number">2</span>), *(p1 + <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ntohs</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> c = <span class="number">0x0304</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c: %x\n&quot;</span>, c);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d = ntohs(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d: %x\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h3><ul>
<li>socket是一系列网络通信的API</li>
</ul>
<blockquote>
<p>客户端 -&gt; 服务器(IP, Port)</p>
<p>socket其实就是一个结构体，封装端口号和IP的信息。后面socket相关的API需要使用这个socket地址</p>
</blockquote>
<ul>
<li><p>通过socket地址</p>
<ul>
<li>socket网络编程接口中表示socket地址是结构体sockaddr，其定义如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span> </span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; </span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>]; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sa_family : 地址族类型sa_family_t的变量。地址族类型通常与协议族类型对应。常见的协议族(protocol family，也称domain)和对应的地址族表示如下</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址族</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP&#x2F;IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP&#x2F;IPv6协议族</td>
</tr>
</tbody></table>
<ul>
<li><p>​	*宏 PF_ * 和 AF_ * 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，**所以二者通常混</p>
<p>用。</p>
</li>
<li><p><strong>sa_data</strong> 成员用于存放 socket 地址值。但是，<strong>不同的协议族的地址值具有不同的含义和长度</strong>，如下所</p>
<p>示：</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>协议族</strong></th>
<th><strong>地址值含义和长度</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>文件的路径名，长度可达到108字节</td>
</tr>
<tr>
<td>PF_INET</td>
<td>16 bit 端口号和 32 bit IPv4 地址，共 6 字节</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>16 bit 端口号，32 bit 流标识，128 bit IPv6 地址，32 bit 范围 ID，共 26 字节</td>
</tr>
</tbody></table>
<p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新                                                                    的</p>
<p>通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span> </span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align; </span><br><span class="line">    <span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<h4 id="专用的socket地址-struct-socket-in"><a href="#专用的socket地址-struct-socket-in" class="headerlink" title="专用的socket地址 struct socket_in"></a>专用的socket地址 struct socket_in</h4><p><img src="https://img-blog.csdnimg.cn/731047d0de88428e9057d66e32dc35bb.png" alt="image-20230908141036871"></p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/0456e003676d4f479be986accccfb75f.png" alt="image-20230908141258677"><ul>
<li>专用socket地址类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr(强制转换)，因为所有socket编程接口使用的地址参数类型都是sockaddr</li>
</ul>
</li>
</ul>
<h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><ul>
<li><p>两个功能</p>
<ul>
<li><strong>将字符串IP和整数相互之间的转换</strong></li>
<li><strong>主机字节序和网络字节序之间的转换</strong></li>
</ul>
</li>
<li><p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用</p>
<p>十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录</p>
<p>日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字</p>
<p>符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>; </span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>下面这对更新的函数跟上面3个函数有同样的功能,并且他们同时适用IPv4和IPv6</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>; </span><br><span class="line">    af:地址族: AF_INET AF_INET6</span><br><span class="line">    src:需要转换的点分十进制的IP字符串</span><br><span class="line">    dst:转换后的结果保存在这个里面</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串 </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">    af：地址族： AF_INET AF_INET6</span><br><span class="line">    src：要转换的IP的整数的地址</span><br><span class="line">    st：转换成IP地址字符串保存的地方</span><br><span class="line">    size：第三个参数的大小(数组的容量)</span><br><span class="line">    返回值:返回转换后的数据的地址(字符串)，和dst是一样的</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">    // p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="comment">    int inet_pton(int af, const char *src, void *dst);</span></span><br><span class="line"><span class="comment">        af:地址族: AF_INET AF_INET6</span></span><br><span class="line"><span class="comment">        src:需要转换的点分十进制的IP字符串</span></span><br><span class="line"><span class="comment">        dst:转换后的结果保存在这个里面</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="comment">    const char * inet_ntop(int af, const void *src, char *dst, socklen_t size);</span></span><br><span class="line"><span class="comment">        af：地址族： AF_INET AF_INET6</span></span><br><span class="line"><span class="comment">        src：要转换的IP的整数的地址</span></span><br><span class="line"><span class="comment">        st：转换成IP地址字符串保存的地方</span></span><br><span class="line"><span class="comment">        size：第三个参数的大小(数组的容量)</span></span><br><span class="line"><span class="comment">        返回值:返回转换后的数据的地址(字符串)，和dst是一样的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个点分十进制的IP字符串</span></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;192.168.1.4&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="comment">// 将点分十进制的IP字符串转换成网络字节序的整数</span></span><br><span class="line">    inet_pton(AF_INET, buf, &amp;num);  <span class="comment">// AF_INET 代表IPv4</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p + <span class="number">1</span>), *(p + <span class="number">2</span>), *(p + <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将网络字节序的IP整数转换成点分十进制的IP字符串</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = inet_ntop(AF_INET, &amp;num, ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str: %s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip: %s\n&quot;</span>, ip);  <span class="comment">// str 和 IP的地址是相同的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h3><ul>
<li><p>TCP和UDP</p>
<p><img src="https://img-blog.csdnimg.cn/5e81270c204c4008abb7f79eb7e7956d.png" alt="image-20230908192756695"></p>
</li>
<li><p>TCP通信流程</p>
<p><img src="https://img-blog.csdnimg.cn/67cf2721c02d4414b82112c0366eab80.png" alt="image-20230908192859209"></p>
</li>
<li><p>服务器端</p>
</li>
</ul>
<blockquote>
<p>被动接受链接</p>
<ul>
<li>1.创建一个监听套接字<ul>
<li>监听有客户端的链接</li>
<li>套接字：这个套接字其实就是一个文件描述符</li>
</ul>
</li>
<li>2.将这个监听的文件描述符和本地的IP和端口绑定<ul>
<li>IP和端口就是服务器的地址信息</li>
<li>客户端连接服务器的时候使用的就是这个IP和端口</li>
</ul>
</li>
<li>3.设置监听，监听的fd开始工作<ul>
<li>监听的是服务器的读缓冲区是否有数据</li>
</ul>
</li>
<li>4.阻塞等待，当有客户端发起连接，结束阻塞，接受客户端的连接，会得到一个和客户端通信的套接字<ul>
<li>通信的文件描述符和监听的文件描述符不同</li>
</ul>
</li>
<li>5.通信<ul>
<li>接受数据</li>
<li>发送数据</li>
</ul>
</li>
<li>6.通信结束，断开连接</li>
</ul>
</blockquote>
<ul>
<li>TCP客户端通信流程</li>
</ul>
<blockquote>
<ul>
<li>1.创建用于通信的套接字(文件描述符)<ul>
<li>不需要绑定端口和IP</li>
</ul>
</li>
<li>2.连接服务器，需要指定连接的服务器的IP和端口</li>
<li>3.通信<ul>
<li>接受数据</li>
<li>发送数据</li>
</ul>
</li>
<li>4 .通信结束，断开连接</li>
</ul>
</blockquote>
<h4 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略</span></span><br><span class="line"><span class="comment">    #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int socket(int domain, int type, int protocol);</span></span><br><span class="line"><span class="comment">    功能:创建一个套接字</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -domain: 协议族</span></span><br><span class="line"><span class="comment">              Name               Purpose                            Man page</span></span><br><span class="line"><span class="comment">        AF_UNIX  AF_LOCAL     Local communication                   unix(7)</span></span><br><span class="line"><span class="comment">            AF_INET6     IPv6 Internet protocols</span></span><br><span class="line"><span class="comment">            AF_INET      IPv4 Internet protocols                    ip(7)</span></span><br><span class="line"><span class="comment">        -type: 通信过程中使用的协议类型</span></span><br><span class="line"><span class="comment">            SOCK_STREAM 流式协议</span></span><br><span class="line"><span class="comment">            SOCK_DGRAM  报式协议</span></span><br><span class="line"><span class="comment">        - protocol: 具体的协议,一般写0，</span></span><br><span class="line"><span class="comment">            SOCK_STREAM流式协议默认使用TCP</span></span><br><span class="line"><span class="comment">            SOCK_DGRAM 报式协议默认使用UDP</span></span><br><span class="line"><span class="comment">    返回值: 返回文件描述符,操作的就是内核缓冲区</span></span><br><span class="line"><span class="comment">        成功返回fd</span></span><br><span class="line"><span class="comment">        失败返回 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></span><br><span class="line"><span class="comment">    功能: 绑定,将fd和本地的IP + 端口进行绑定</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        -sockfd: 通过socket函数得到的文件描述符</span></span><br><span class="line"><span class="comment">        -addr: 需要绑定的socket地址,这个地址就封装了IP和端口号的信息</span></span><br><span class="line"><span class="comment">        -addrlen: addr结构体占的内存大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn</span></span><br><span class="line"><span class="comment">    功能: 监听这个套接字上的连接</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - sockfd: 通过socket函数得到的文件描述符</span></span><br><span class="line"><span class="comment">        -backlog: 未连接和已经链接的套接字的和的最大值，一般为4096</span></span><br><span class="line"><span class="comment">    成功返回0,失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></span><br><span class="line"><span class="comment">    功能:接受客户端连接,默认是一个阻塞等待连接,阻塞等待客户端连接</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -sockfd: 用于监听的文件描述符</span></span><br><span class="line"><span class="comment">        -addr: 传出参数,记录了连接成功后客户端的地址信息(IP,port)</span></span><br><span class="line"><span class="comment">        -addrlen: 指定第二个参数的文件大小</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">        成功返回用于通信的文件描述符</span></span><br><span class="line"><span class="comment">        失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></span><br><span class="line"><span class="comment">    功能: 客户端连接服务器</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -sockfd: 用于通信的文件描述符</span></span><br><span class="line"><span class="comment">        -addr: 客户端要连接服务器的地址信息</span></span><br><span class="line"><span class="comment">        -addrlen: 第二个参数的内存大小</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回0</span></span><br><span class="line"><span class="comment">        失败返回-1</span></span><br><span class="line"><span class="comment">ssize_t write(int fd, const void *buf, size_t count); // 写数据</span></span><br><span class="line"><span class="comment">ssize_t read(int fd, void *buf, size_t count); // 读数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<ul>
<li>write</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot; 192.168.203.59&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//  给服务器发送数据</span></span><br><span class="line">        <span class="type">char</span>* sendBuf = <span class="string">&quot;hello , i am client&quot;</span>;</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf));</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server close..\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略</span></span><br><span class="line"><span class="comment">    #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int socket(int domain, int type, int protocol);</span></span><br><span class="line"><span class="comment">    功能:创建一个套接字</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -domain: 协议族</span></span><br><span class="line"><span class="comment">              Name               Purpose                            Man page</span></span><br><span class="line"><span class="comment">        AF_UNIX  AF_LOCAL     Local communication                   unix(7)</span></span><br><span class="line"><span class="comment">            AF_INET6     IPv6 Internet protocols</span></span><br><span class="line"><span class="comment">            AF_INET      IPv4 Internet protocols                    ip(7)</span></span><br><span class="line"><span class="comment">        -type: 通信过程中使用的协议类型</span></span><br><span class="line"><span class="comment">            SOCK_STREAM 流式协议</span></span><br><span class="line"><span class="comment">            SOCK_DGRAM  报式协议</span></span><br><span class="line"><span class="comment">        - protocol: 具体的协议,一般写0，</span></span><br><span class="line"><span class="comment">            SOCK_STREAM流式协议默认使用TCP</span></span><br><span class="line"><span class="comment">            SOCK_DGRAM 报式协议默认使用UDP</span></span><br><span class="line"><span class="comment">    返回值: 返回文件描述符,操作的就是内核缓冲区</span></span><br><span class="line"><span class="comment">        成功返回fd</span></span><br><span class="line"><span class="comment">        失败返回 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></span><br><span class="line"><span class="comment">    功能: 绑定,将fd和本地的IP + 端口进行绑定</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        -sockfd: 通过socket函数得到的文件描述符</span></span><br><span class="line"><span class="comment">        -addr: 需要绑定的socket地址,这个地址就封装了IP和端口号的信息</span></span><br><span class="line"><span class="comment">        -addrlen: addr结构体占的内存大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn</span></span><br><span class="line"><span class="comment">    功能: 监听这个套接字上的连接</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        - sockfd: 通过socket函数得到的文件描述符</span></span><br><span class="line"><span class="comment">        -backlog: 未连接和已经链接的套接字的和的最大值，一般为4096</span></span><br><span class="line"><span class="comment">    成功返回0,失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></span><br><span class="line"><span class="comment">    功能:接受客户端连接,默认是一个阻塞等待连接,阻塞等待客户端连接</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -sockfd: 用于监听的文件描述符</span></span><br><span class="line"><span class="comment">        -addr: 传出参数,记录了连接成功后客户端的地址信息(IP,port)</span></span><br><span class="line"><span class="comment">        -addrlen: 指定第二个参数的文件大小</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">        成功返回用于通信的文件描述符</span></span><br><span class="line"><span class="comment">        失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></span><br><span class="line"><span class="comment">    功能: 客户端连接服务器</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -sockfd: 用于通信的文件描述符</span></span><br><span class="line"><span class="comment">        -addr: 客户端要连接服务器的地址信息</span></span><br><span class="line"><span class="comment">        -addrlen: 第二个参数的内存大小</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回0</span></span><br><span class="line"><span class="comment">        失败返回-1</span></span><br><span class="line"><span class="comment">ssize_t write(int fd, const void *buf, size_t count); // 写数据</span></span><br><span class="line"><span class="comment">ssize_t read(int fd, void *buf, size_t count); // 读数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建监听套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot; 192.168.203.59&quot;, saddr.sin_addr.s_addr);</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.接收客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端信息,将其转换成主机字节序</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">// 获取IP</span></span><br><span class="line">    inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">    <span class="comment">// 获取端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;clinet IP is: %s, port is: %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.获取客户端数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = read(cfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client close..\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给客户端发送数据</span></span><br><span class="line">        <span class="type">char</span>* sendBuf = <span class="string">&quot;hello , i am server&quot;</span>;</span><br><span class="line">        write(cfd, sendBuf, <span class="built_in">strlen</span>(sendBuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><blockquote>
<p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。<strong>所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等</strong>。 TCP 可以看成是一种<strong>字节流</strong>，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程 中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 四次挥手 来关闭一个连接。</p>
</blockquote>
<ul>
<li>三次握手<ul>
<li>目的是保证双方互相之间建立了连接</li>
</ul>
</li>
<li>TCP头部信息<ul>
<li><img src="https://img-blog.csdnimg.cn/6b4ac35d28de42d9b61640cf3fd18ea8.png" alt="image-20230909093153480"></li>
</ul>
</li>
</ul>
<blockquote>
<p>三次握手发生在客户端连接的时候，当客户端调用connect()，底层会通过TCP协议进行三次握手</p>
</blockquote>
<ul>
<li><p>三次握手时序图</p>
<p><img src="https://img-blog.csdnimg.cn/c0e7c22df0b14676956532c40055427a.png" alt="image-20230909094819496"></p>
<blockquote>
<p>第一次握手:</p>
<p>​	1.客户端将SYN标志置为1</p>
<p>​	2.生成一个随机的32位的序号，这个序号后边是可以携带数据(数据的大小)</p>
<p>第二次握手</p>
<p>​	1.服务器端接收客户端的连接：ACK &#x3D; 1</p>
<p>​	2.服务器回发一个确认信号ack &#x3D; 客户端的seq + 数据长度 + SYN&#x2F;FIN(占1B)</p>
<p>​	3.服务器向客户端发起连接请求：SYN &#x3D; 1</p>
<p>​	4.服务器生成一个随机序号：seq &#x3D; k</p>
<p>第三次握手</p>
<p>​	1.客户端应答服务器的连接请求：ACK &#x3D; 1；</p>
<p>​	2.客户端回复收到服务器端的数据：ack &#x3D; 服务器的序号 + 数据长度 + SYN&#x2F;FIN(占1B)</p>
</blockquote>
<ul>
<li><p>根据TCP头部信息进行三次握手</p>
<p><img src="https://img-blog.csdnimg.cn/e94ba12d55f94ffbb62c8e5e1b5be912.png" alt="image-20230909095025536"></p>
</li>
<li><p>双方确认两者的接发数据功能没问题至少<strong>需要三次握手</strong></p>
</li>
</ul>
</li>
<li><p>怎么确定发送的数据是完整的？</p>
<blockquote>
<p>为每个字节分配一个32位序号，seq是字节序第一个字节的序号</p>
<p>ack为期望收到的下一个字节的序号(即上一次收到的字节序中最后一个字节的序号 + 1)</p>
</blockquote>
<ul>
<li>搞清楚每一个信号的原因!</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2f5a01edc2ea47aaa0fbe2b43a933b52.png" alt="image-20230909101348440"></p>
</li>
<li><p>怎么确定接收和发送顺序是一样的？</p>
<blockquote>
<p>滑动窗口</p>
</blockquote>
</li>
</ul>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><blockquote>
<p>滑动窗口（Sliding window）是一种<strong>流量控制</strong>技术。早期的网络通信中，通信双方不会考虑网络的 拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包， 谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包 （称窗口尺寸）。 <strong>TCP 中采用滑动窗口来进行传输控制，</strong>滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报。 滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构</p>
</blockquote>
<ul>
<li>窗口理解为缓冲区的大小<ul>
<li>滑动窗口的大小会随着发送数据和接收数据而变化</li>
<li>通信双方都有发送缓冲区和接收缓冲区</li>
</ul>
</li>
<li><img src="https://img-blog.csdnimg.cn/19be4b526587439390d998fcd031c959.png" alt="image-20230909104107465"></li>
</ul>
<blockquote>
<p>发送方缓冲区</p>
<p>​	白色格子：空闲的空间</p>
<p>​	灰色格子：数据已经被发送出去了，但是还没有被接受</p>
<p>​	粉色格子：还未发送的数据</p>
<p>接收方缓冲区</p>
<p>​	白色格子：空闲的空间</p>
<p>​	粉色格子：已经接受到的数据</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/96a29dd560bf43389069ea008e5f85d7.png" alt="image-20230909104422000"></p>
<blockquote>
<p>MSS：maximum segment size (一条数据的最大数据量)</p>
<p>win：滑动窗口大小</p>
<p>1.客户端给服务器发起连接，客户端的滑动窗口大小4096，一次发送的最大数据量为1460</p>
<p>2.服务器接受连接请求，告诉客户端服务器窗口大小6144，一次发送的最大数据量为1024</p>
<p>3.<strong>第三次握手</strong></p>
<p>4-9.客户端连续给服务器发送了6k数据，每次发送1k</p>
<p>10.服务器给客户端发送数据，告诉客户端服务器已经接受了6k数据，存储在缓冲区中，剩余空间2k</p>
<p>11.服务器给客户端发送数据，告诉客户端服务器已经接受了6k数据，存储在缓冲区中，剩余空间4k</p>
<p>12.客户端给服务器发送1k数据</p>
<p>13.客户端主动请求断开连接，并且给服务器发送了1k的数据</p>
<p>14.服务器收到，回复ACK8194(同意断开连接请求(+1)，告诉客户端已经接收到刚才发的2k数据)，滑动窗口剩余2k</p>
<p>15-16.通知客户端滑动窗口大小</p>
<p>17.<strong>第三次挥手</strong>：服务器给客户端发送FIN，请求断开连接</p>
<p>18.<strong>第四次挥手</strong>：客户端同意断开连接，连接彻底断开</p>
</blockquote>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><blockquote>
<p>四次挥手：在程序中当调用了close()会使用TCP协议进行四次挥手</p>
<p>客户端和服务端都可以主动发起断开连接，谁调用close()谁就发起</p>
<p>因为TCP在建立连接时，采用三次握手建立双向连接，在断开的时候也需要双向断开</p>
</blockquote>
<p> <img src="https://img-blog.csdnimg.cn/e024ca2c585f473b8d6115cfa0cfdc94.png" alt="image-20230909110059973"></p>
<p><img src="https://img-blog.csdnimg.cn/4091d8cfd6a347f3b8295c83fb01d3d7.png" alt="image-20230909105622736"></p>
<h3 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h3><blockquote>
<p>要实现TCP通信服务器并发处理任务，使用多线程或者多进程解决</p>
<p>思路：</p>
<p>​	1.一个父进程，多个子进程</p>
<p>​	2.父进程负责等待并接受客户端的连接</p>
<p>​	3.子进程负责完成通信，接受一个客户端连接就创建一个子进程用于通信</p>
</blockquote>
<ul>
<li>多进程通信的服务器端实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recyleChild</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);  <span class="comment">//-1 回收所有子进程 WNOHANG设置非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;所有的子进程回收\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recyleChild;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = ntohs(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// accept</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;caddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                <span class="comment">// 产生中断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="type">char</span> clientIP[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            inet_ntop(AF_INET, &amp;caddr.sin_addr.s_addr, clientIP, <span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> port;</span><br><span class="line">            port = ntohs(caddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;clinet IP: %s, port: %x\n&quot;</span>, clientIP, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> readLen = read(cfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="keyword">if</span> (readLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client: %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed..\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readLen == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 回写数据</span></span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="comment">// 退出子进程</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>多进程通信的客户端实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot; 192.168.203.59&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//  给客户端发送数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data: %d\n&quot;</span>, i++);</span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server close..\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多线程实现并发服务器"><a href="#多线程实现并发服务器" class="headerlink" title="多线程实现并发服务器"></a>多线程实现并发服务器</h3><ul>
<li>客户端与多进程不变</li>
<li>服务器端的实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 通信的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;  <span class="comment">// 线程号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> <span class="title">sockinfos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">working</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 子线程和客户端通信   cfd 客户端的信息 线程号</span></span><br><span class="line">    <span class="comment">// 获取客户端的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span> =</span> (<span class="keyword">struct</span> sockInfo *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(pinfo-&gt;addr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = read(pinfo-&gt;fd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pinfo-&gt;fd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(pinfo-&gt;fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="type">int</span> max = <span class="keyword">sizeof</span>(sockinfos) / <span class="keyword">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        bzero(&amp;sockinfos[i], <span class="keyword">sizeof</span>(sockinfos[i]));</span><br><span class="line">        sockinfos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        sockinfos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 从这个数组中找到一个可以用的sockInfo元素</span></span><br><span class="line">            <span class="keyword">if</span>(sockinfos[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                pinfo = &amp;sockinfos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max - <span class="number">1</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pinfo-&gt;fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr, &amp;cliaddr, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line"></span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><blockquote>
<p>状态转换发生在三次握手和四次挥手的时候</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/c2be216631ee45248549d6b953b89e67.png" alt="image-20230910122813061"></p>
<ul>
<li>三次握手的状态转换</li>
</ul>
<blockquote>
<p>1.客户端调用connect发送SYN请求之后，变成<strong>SYN_SENT</strong>状态</p>
<p>2.服务器接受到请求连接报文，转换成<strong>SYN_RCVD</strong>状态，像客户端发送确认报文</p>
<p>3.客户端接收到确认报文，状态变为<strong>ESTABLISHED</strong></p>
</blockquote>
<ul>
<li>四次挥手的状态转换</li>
</ul>
<blockquote>
<p>1.客户端发送FIN断开连接，状态变为<strong>FIN_WAIT_1</strong></p>
<p>2.服务器接收到断开连接请求，状态变为<strong>CLOSE_WAIT</strong>，并发送确认报文给客户端</p>
<p>3.客户端接收到确认报文，状态转换为<strong>FIN_WAIT2</strong></p>
<p>4.服务器发送断开连接请求报文给客户端，状态变为<strong>LAST_ACK</strong></p>
<p>5.客户端接受到报文，状态变为<strong>TIME_WAIT</strong>，并发送确认报文</p>
<p>四次挥手之后两边都变成<strong>close</strong>状态(既是起点，也是重点)</p>
</blockquote>
<ul>
<li><p><img src="https://img-blog.csdnimg.cn/ae6805326c9b48e5a61fead19985c93a.png" alt="image-20230910124941349"></p>
<ul>
<li>黑色线：异常(暂时忽略)</li>
<li>绿色虚线：服务端</li>
<li>红色实线：客户端</li>
</ul>
</li>
<li><p>TIME_WAIT定时经过两倍的报文端寿命之后(<strong>2MSL</strong>)，才会结束</p>
<p>为什么呢？</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>第二次挥手和第三次挥手之间可能间隔时间长，还可以发送数据</p>
</li>
<li><p>确保数据安全性，确保收到所有数据</p>
</li>
<li><p>确保通信另一段正确接受ACK</p>
<ul>
<li>比如服务端也可能没有收到ACK，需要客户端重新发送，也要求客户端不能立即断开</li>
<li>被动房重传的不是ACK，是<strong>FIN</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/48e5315a8cfb4c18abcec564d83577ee.png" alt="image-20230910130012761"></p>
<h3 id="半关闭和端口复用"><a href="#半关闭和端口复用" class="headerlink" title="半关闭和端口复用"></a>半关闭和端口复用</h3><ul>
<li>只要调用close之后就不能发送数据了<ul>
<li>四次挥手之后发送ack是协议的行为，不能发送带有数据的报文</li>
<li>可以接受数据</li>
</ul>
</li>
</ul>
<blockquote>
<p>当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2 状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发 送的数据，但是 A 已经不能再向 B 发送数据。</p>
</blockquote>
<ul>
<li>shutdown函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line">	sockfd: 需要关闭的socket的描述符</span><br><span class="line">	how: 允许为shutdown操作选择以下几种方式:</span><br><span class="line">		SHUT_RD(<span class="number">0</span>)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">			该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">		SHUT_WR(<span class="number">1</span>): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发</span><br><span class="line">			出写操作。</span><br><span class="line">		SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以</span><br><span class="line">			SHUT_WR。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <strong>close</strong> 中止一个连接，但它<strong>只是减少描述符的引用计数，并不直接关闭连接</strong>，只有<strong>当描述符的引用计数为 0 时才关闭连接</strong>。<strong>shutdown 不考虑描述符的引用计数，直接关闭描述符</strong>。也可选择中止一个方向的连接，只中止读或只中止写。</p>
</blockquote>
<ul>
<li>如果有多进程共享一个套接字，close每调用一次，计数-1，直到计数为0。也就是所有进程都调用了close，套接字将被释放</li>
<li>在多进程中如果一个进程调用了shutdown(sfd，SHUT_RDWR)之后，其他的进程将无法进行通信，但如果一个进程close(sfd)不会影响到其他进程</li>
</ul>
<hr>
<ul>
<li>端口复用</li>
<li><strong>查看网络信息相关的命令</strong></li>
</ul>
<blockquote>
<p>net-stat</p>
<p>​	-a 所有的socket</p>
<p>​	-p 显示正在使用socket的程序的名称</p>
<p>​	-n 直接使用IP地址，而不通过域名服务器</p>
</blockquote>
<ul>
<li><p>setsockopt()</p>
<p>​	解决问题：</p>
<ul>
<li>1.放置服务器重启时之前绑定的端口还未释放</li>
<li>2.程序突然退出而系统端口还未释放</li>
</ul>
</li>
<li><p>不仅仅设置端口复用，设置套接字的属性</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">	-sockfd:要操作的文件描述符</span><br><span class="line">	-level：级别,SOL_SOCKET(端口复用级别)</span><br><span class="line">	-optname：选项的名称</span><br><span class="line">        SO_REUSEADDR</span><br><span class="line">        SO_REUSEPORT</span><br><span class="line">	-optval：端口复用的值，是一个整形</span><br><span class="line">        <span class="number">1</span>：端口可复用</span><br><span class="line">        <span class="number">2</span>：不可复用</span><br><span class="line">	-optlen：optval参数的大小</span><br><span class="line">端口复用设置的时机：服务器绑定端口之前</span><br></pre></td></tr></table></figure>

<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><blockquote>
<p>I&#x2F;O多路复用使得程序能<strong>同时监听多个文件描述符</strong>，能<strong>提高程序的性能</strong>，Linux下实现I&#x2F;O多路复用的系统调用主要有<strong>select、poll和epoll</strong></p>
</blockquote>
<ul>
<li>传统的I&#x2F;O指的是程序和内存之间的输入输出</li>
</ul>
<hr>
<h4 id="几种IO模型"><a href="#几种IO模型" class="headerlink" title="几种IO模型"></a>几种IO模型</h4><ul>
<li>阻塞等待BIO<ul>
<li>好处：不占用CPU宝贵的时间片</li>
<li>缺点：同一时刻只能处理一个操作，效率低</li>
</ul>
</li>
<li>解决：<strong>使用多线程或者多进程方式解决</strong><ul>
<li>优点：解决效率低的问题</li>
<li>缺点：<ul>
<li>线程或者进程会消耗资源</li>
<li>线程或进程调度消耗CPU资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>非阻塞，忙轮询NIO<ul>
<li>优点：提高了程序的执行效率</li>
<li>缺点：需要占用更多的CPU和系统资源<ul>
<li>每次循环都会一次询问，时间复杂度N(O)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>多路转接计数</p>
<ul>
<li>select</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/6e7d0e3dd7934a07858e37e7230e3ea7.png" alt="image-20230910161139291"></p>
<ul>
<li>底层是<strong>二进制数组</strong>，只知道有多少，不知道具体是哪几个文件描述符</li>
</ul>
</li>
<li><p>epoll</p>
<ul>
<li>同样也是委托内核，不仅能检测有几个，还能找出具体的文件描述符</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/bcefd474ef404c91938d8afce835dd58.png" alt="image-20230910161327082"></p>
</li>
</ul>
<h4 id="selectAPI"><a href="#selectAPI" class="headerlink" title="selectAPI"></a>selectAPI</h4><ul>
<li><strong>主旨思想</strong></li>
</ul>
<blockquote>
<p>1.首先构造一个关于<strong>文件描述符的列表</strong>，将要监听的文件描述符添加到该列表中。</p>
<p>2.调用一个系统函数，<strong>监听</strong>该列表中的文件描述符，直到这些描述符中的一个或者多个进行I&#x2F;O操作时，该函数才返回</p>
<p>​	该<strong>函数是阻塞</strong>的，当检测到这些描述符中的一个或者多个进行I&#x2F;O操作时才返回</p>
<p>​	<strong>函数对文件描述符的检测的操作是由内核完成的</strong></p>
<p>3.返回时会告诉进程有哪些描述符要进行I&#x2F;O操作。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(fd_set) = 128 1024位</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line">	参数</span><br><span class="line">        -nfds：委托内核检测的最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">     	 -readfds：要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">        	一般检测读操作</span><br><span class="line">        	对应的是对方发送过来的数据，因为读是被动的接受数据，检测的是读缓冲区</span><br><span class="line">        	是一个传入传出参数，内核会修改fd_set中的值并返回，这也是为什么用指针</span><br><span class="line">        -writefds：要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">        	检测的是写缓冲区还有多少空余缓存，一般不使用</span><br><span class="line">        -exceptfds:检测发生异常的文件描述符的集合，一般不使用</span><br><span class="line">        -timeout：一个结构体，设置的超时时间</span><br><span class="line">        	 <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">               <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">               <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">           &#125;;</span><br><span class="line">		  	值为<span class="literal">NULL</span>：永久阻塞直到检测到了文件描述符的变化、</span><br><span class="line">          tv_sec == <span class="number">0</span>  &amp;&amp; tv_usec == <span class="number">0</span>：不阻塞</span><br><span class="line">          tv_sec &gt; <span class="number">0</span>  &amp;&amp; tv_usec &gt; <span class="number">0</span>：阻塞对应的时间</span><br><span class="line">    返回值：</span><br><span class="line">        失败返回<span class="number">-1</span></span><br><span class="line">        n(&gt;<span class="number">0</span>)：检测到的集合中有n个文件描述符发生了变化</span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="type">void</span> FD_CLR(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>; </span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>select工作分析过程</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/f10d859db7d14124b19b23d26e612456.png" alt="image-20230910195454961"></p>
<ul>
<li>select的使用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set集合,存放的是需要检测的文件描述符</span></span><br><span class="line">    <span class="comment">// 让tmp集合交给内核操作,rdset只能通过函数调用修改</span></span><br><span class="line">    fd_set rdset, tmp;</span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        tmp = rdset;</span><br><span class="line">        <span class="comment">// 调用select系统函数,让内核帮忙检测那些文件描述符有数据</span></span><br><span class="line">        ret = select(maxfd + <span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 检测到了有文件描述符对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(lfd, &amp;tmp)) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                FD_SET(cfd, &amp;rdset);</span><br><span class="line">                <span class="comment">// 更新最大的文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i++) &#123;</span><br><span class="line">                <span class="comment">// lfd一定是在最前面的,所有从后面开始监听</span></span><br><span class="line">                <span class="keyword">if</span> (FD_ISSET(i, &amp;tmp)) &#123;</span><br><span class="line">                    <span class="comment">// i文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="comment">// 通信</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> readlen = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span> (readlen == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readlen == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        FD_CLR(i, &amp;rdset);</span><br><span class="line">                        close(i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf: %s\n&quot;</span>, buf);</span><br><span class="line">                        write(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>总结<ul>
<li>缺点<ul>
<li>每次调用<strong>select要将fds从用户态拷贝到内核态</strong>，资源消耗大</li>
<li>每次调用select都需要<strong>在内核遍历传递进来的所有fd</strong>，开销也很大</li>
<li>select支持的文<strong>件描述符数量小，默认是1024</strong></li>
<li>fds集合不能重用，每次都需要重置。一般需要定义另外一个来使用，<strong>需要额外开闭数组</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="pollAPI"><a href="#pollAPI" class="headerlink" title="pollAPI"></a>pollAPI</h4><p><img src="https://img-blog.csdnimg.cn/b70a1b511f7747e59a39ed34d21d2e52.png" alt="image-20230911090510865"></p>
<ul>
<li>poll服务器代码实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;poll.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     struct pollfd &#123;</span></span><br><span class="line"><span class="comment">        int   fd;          file descriptor</span></span><br><span class="line"><span class="comment">        short events;      requested events</span></span><br><span class="line"><span class="comment">        short revents;    returned events</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -fds: 是一个struct pollfd结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="comment">        -nfds: 这个是第一个参数数组中最后一个有效元素的下标 + 1、</span></span><br><span class="line"><span class="comment">        -timeout: 阻塞时长</span></span><br><span class="line"><span class="comment">            0: 不阻塞</span></span><br><span class="line"><span class="comment">            -1: 阻塞,当检测到需要检测的文件描述符有变化时解除阻塞</span></span><br><span class="line"><span class="comment">            &gt; 0: 阻塞时长</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        -1 表示失败</span></span><br><span class="line"><span class="comment">        &gt;0(n) 表示成功,集合中有n个文件描述符发生变化</span></span><br><span class="line"><span class="comment">    int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测文件描述符数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用select系统函数,让内核帮忙检测那些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = poll(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 检测到了有文件描述符对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新最大的文件描述符</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="comment">// lfd一定是在最前面的,所有从后面开始监听</span></span><br><span class="line">                <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    <span class="comment">// i文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="comment">// 通信</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> readlen = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span> (readlen == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readlen == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client: %d closed...\n&quot;</span>, fds[i].fd);</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf: %s\n&quot;</span>, buf);</span><br><span class="line">                        write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结<ul>
<li><strong>poll解决了select支持文件描述符数量小和fds不能重复使用，每次都需要重置的缺点</strong></li>
</ul>
</li>
</ul>
<h4 id="epollAPI"><a href="#epollAPI" class="headerlink" title="epollAPI"></a>epollAPI</h4><ul>
<li><p>epoll_create<strong>创建的实例在内核区</strong>，eventpoll，是一个<strong>结构体数据</strong>。返回值是文件描述符，利用它对内核中的结构体进行操作(并不是直接操作，调用API)</p>
<ul>
<li><strong>没有用户态到内核态的开销，提高了效率</strong></li>
<li><strong>底层是红黑树，遍历效率高</strong>，之前两个API是线性数组</li>
</ul>
</li>
<li><p>epoll_wait会向用户区返回哪些文件描述符发生改变</p>
<ul>
<li>这里的交换只有一次，速度很快。而且会返回具体哪些fd发生改变</li>
</ul>
</li>
<li><p>rb_root-&gt;红黑树   list_head -&gt; 链表</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c3cac9c3ab0944d8ab8c2f2603bf06f1.png" alt="image-20230911094439422"></p>
<ul>
<li>epoll服务器的简单实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/epoll.h&gt;</span></span><br><span class="line"><span class="comment">    功能: 创建一个新的epoll实例，在内核中创建一个数据，这个数据</span></span><br><span class="line"><span class="comment">          有两个重要数据：一个是需要检测的文件描述符的信息(红黑树)</span></span><br><span class="line"><span class="comment">          另一个是就绪列表，存放检测数据发送改变的文件描述符信息(双向链表)</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -size 改版之后无意义，随便填一个大于0的书</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回&gt;0：文件描述符，操作epoll实例</span></span><br><span class="line"><span class="comment">        失败返回-1</span></span><br><span class="line"><span class="comment">-    int epoll_create(int size);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    功能: 对epoll实例进行管理,添加文件描述符信息，删除修改信息</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -epfd：epoll实例对应的文件描述符</span></span><br><span class="line"><span class="comment">        -op：要进行什么操作</span></span><br><span class="line"><span class="comment">            EPOLL_CTL_ADD:添加</span></span><br><span class="line"><span class="comment">            EPOLL_CTL_MOD:修改</span></span><br><span class="line"><span class="comment">            EPOLL_CTL_DEL:删除</span></span><br><span class="line"><span class="comment">        -fd：要检测的文件描述符</span></span><br><span class="line"><span class="comment">        -event：检测文件描述符什么事情</span></span><br><span class="line"><span class="comment">            struct epoll_event &#123;</span></span><br><span class="line"><span class="comment">                uint32_t      events;  Epoll events</span></span><br><span class="line"><span class="comment">                epoll_data_t  data;     User data variable</span></span><br><span class="line"><span class="comment">            &#125;;</span></span><br><span class="line"><span class="comment">        常见的epoll检测事件</span></span><br><span class="line"><span class="comment">            EPOLLIN</span></span><br><span class="line"><span class="comment">            EPOLLOUT</span></span><br><span class="line"><span class="comment">            EPOLLERR</span></span><br><span class="line"><span class="comment">        typedef union epoll_data &#123; //联合体,只有一个会存在</span></span><br><span class="line"><span class="comment">           void     *ptr;</span></span><br><span class="line"><span class="comment">           int       fd;</span></span><br><span class="line"><span class="comment">           uint32_t  u32;</span></span><br><span class="line"><span class="comment">           uint64_t  u64;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">-    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *_Nullable event);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    功能：检测函数</span></span><br><span class="line"><span class="comment">    参数</span></span><br><span class="line"><span class="comment">        -epfd:epoll实例对应的文件描述符</span></span><br><span class="line"><span class="comment">        -events：传出参数，保存了发生变化的文件描述符的信息</span></span><br><span class="line"><span class="comment">        -maxevents：第二个结构体参数的大小</span></span><br><span class="line"><span class="comment">        -timeout：阻塞事件</span></span><br><span class="line"><span class="comment">            0表示不阻塞</span></span><br><span class="line"><span class="comment">            -1表示阻塞，直到检测到fd数据发生变化时解除阻塞</span></span><br><span class="line"><span class="comment">            &gt; 0 阻塞时长(mm)</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">        成功返回&gt;0的数，表示变化的文件描述符的个数</span></span><br><span class="line"><span class="comment">        失败返回 -1</span></span><br><span class="line"><span class="comment">-    int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用epoll_create() 创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将监听的文件描述符的监测信息加到epoll的实例当中(内核中)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存内核检测之后返回的文件描述符的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ret是检测到有多少个文件描述符发生改变的值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epevs[i].data.fd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据到达,即有新的客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">                <span class="comment">// 封装cfd文件描述符的信息到内核中，进行监听</span></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;检测到写\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有数据到达,需要通信</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(epevs[i].data.fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client %d closed...\n&quot;</span>, epevs[i].data.fd);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, epevs[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(epevs[i].data.fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf: %s\n&quot;</span>, buf);</span><br><span class="line">                    write(epevs[i].data.fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="epoll的工作模式"><a href="#epoll的工作模式" class="headerlink" title="epoll的工作模式"></a>epoll的工作模式</h4><ul>
<li><strong>LT模式(水平触发)</strong></li>
<li>假设委托内核检测读事件<ul>
<li>-&gt;检测fd的读缓冲区<ul>
<li>若读缓冲区有数据-&gt;epoll检测到了会通知用户<ul>
<li>若用户不读数据，数据一直在缓冲区，epoll下一次会继续通知用户</li>
<li>若用户只读了一部分数据，epoll也会通知</li>
<li>若缓冲区数据读完，epoll不通知</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/4caeda1f4fde4127bb86e3b1a33d3e1c.png" alt="image-20230911154558253"></p>
<blockquote>
<p>LT（level - triggered）是<strong>缺省的工作方式</strong>（默认的工作模式），并且<strong>同时支持 block 和 no-block socket</strong>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操</p>
<p>作。如果你<strong>不作任何操作，内核还是会继续通知你的</strong></p>
<p>​	- 在一个文件描述符中，读缓冲区有数据，你只读了一部分，epoll下一次还是会通知你。除非读完</p>
</blockquote>
<ul>
<li><strong>ET模式(边沿触发)</strong></li>
<li>假设委托内核检测读事件<ul>
<li>-&gt;检测fd 的读缓冲区<ul>
<li>若读缓冲区有数据-&gt;epoll检测到了会通知用户<ul>
<li>若用户不读数据，数据一直在缓冲区中，epoll下次检测时不通知</li>
<li>若用户读了一部分数据，epoll也不会通知</li>
<li>若数据读完，也不会通知</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>ET（edge - triggered）是<strong>高速工作方式</strong>，<strong>只支持 no-block socket</strong>。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，<strong>直到你做了某些操作导致那个文件描述符不再为就绪状态了</strong>。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（<strong>only once</strong>）。ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，<strong>必须使用非阻塞套接口</strong>，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>​	-当fd缓冲区中有数据了，<strong>epoll会且仅会通知你一次</strong>，若数据未读完，下一次也不会再通知，只有当你将缓存中的数据完全读完了，下一次有数据时epoll才会通知</p>
<p>​	-效率比水平触发高，但是需要循环读数据将数据全部读出来。但是read读不到数据可能会阻塞，所以需要使用no-block socket</p>
</blockquote>
<h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><p><img src="https://img-blog.csdnimg.cn/721e7a7429994ec1891ad87ae668e0e4.png" alt="image-20230911205705304"></p>
<ul>
<li>UDP不需要多线程或者多进程就可以实现多个客户端进行通信</li>
<li>服务器端代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">18</span>];</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;revcfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP: %s, Port: %d\n&quot;</span>,</span><br><span class="line">               inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">               ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>, recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, recvbuf, <span class="built_in">strlen</span>(recvbuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">18</span>];</span><br><span class="line">        <span class="type">char</span> sendbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendbuf, <span class="string">&quot;hello , i am clent %d\n&quot;</span>, num++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, sendbuf, <span class="built_in">strlen</span>(sendbuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say: %s\n&quot;</span>, sendbuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><blockquote>
<p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息。每个广播消息都有一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全为1，255为广播IP</p>
<p>1.<strong>只能在局域网中使用</strong></p>
<p>2.客户端需要绑定服务器广播使用的端口，才可以接受到广播消息</p>
</blockquote>
<h3 id="组播-多播"><a href="#组播-多播" class="headerlink" title="组播(多播)"></a>组播(多播)</h3><ul>
<li>多播地址标识一组IP接口。单播和广播是寻址方案的两个极端(要么单个要么全部)，多播则意在两者之间提供一种折中的方案。</li>
<li>多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应的多播会话应用系统的主机上的接口接收</li>
<li>广播一般局限于局域网内使用，而组播则既可以用于局域网，也可以跨广域网使用<ul>
<li>组播既可以用于局域网，也可以用于广域网</li>
<li>客户端需要加入组播组，才能接收到组播的数据</li>
</ul>
</li>
<li><img src="https://img-blog.csdnimg.cn/5e9c32bb70ee4dbd866b0062c252cbd1.png" alt="image-20230913201916158"></li>
<li>组播地址(224.0.0.0到239.255.255.255)<ul>
<li><img src="https://img-blog.csdnimg.cn/7cb8a64297ac4b58b2157cfe187ff073.png" alt="image-20230913202027081"></li>
<li></li>
</ul>
</li>
</ul>
<h3 id="本地套接字通信"><a href="#本地套接字通信" class="headerlink" title="本地套接字通信"></a>本地套接字通信</h3><blockquote>
<p>作用：本地的进程间通信</p>
<p>​	有关系的进程间的通信</p>
<p>​	没有关系的进程间的通信</p>
</blockquote>
<ul>
<li><p>本地套接字通信流程</p>
<p>服务器端(一般按TCP流程通信)</p>
</li>
</ul>
<blockquote>
<p>1.创建监听的套接字</p>
<p>​	int lfd &#x3D; socket(AF_LOCAL &#x2F; AF_LOCAL, SOCK_STREM, 0);</p>
<p>2.监听的套接字绑定本地的套接字文件 -&gt; server端</p>
<p>​	struct sockaddr_un addr;</p>
<p>​	&#x2F;&#x2F;绑定成功之后，指定的sum_path中的套接字文件会自动生成</p>
<p>​	bind(lfd, addr, len);</p>
<p>3.监听</p>
<p>​	listen(lfd, 100);</p>
<p>4.等待并接受连接请求</p>
<p>​	struct socket_un cliaddr;</p>
<p>​	int cfd &#x3D; accept(lfd, &amp;liaddr, len);</p>
<p>5.通信</p>
<p>​	接收数据：read&#x2F;recv</p>
<p>​	发送数据：write&#x2F;send</p>
<p>6.关闭连接</p>
<p>​	close(lfd);</p>
<p>​	closee(cfd);</p>
</blockquote>
<ul>
<li>客户端</li>
</ul>
<blockquote>
<p>1.创建通信的套接字</p>
<p>​	int fd &#x3D; socket(AF_UNIX&#x2F; AF_LOCAL, SOCK_STREAM, 0);</p>
<p>2.监听的套接字绑定本地的IP和端口</p>
<p>​	struct sockaddr_un addr;</p>
<p>​	&#x2F;&#x2F;绑定成功之后， 指定的sun_path中的套接字文件会自动生成</p>
<p>​	bind(fd, &amp;addr, len);</p>
<p>3.连接服务器</p>
<p>​	struct sockaddr_un server_addr;</p>
<p>​	connect(fd, &amp;server_addr, sizof(server_addr));</p>
<p>4.通信</p>
<p>​	接收数据：read&#x2F;recv</p>
<p>​	发送数据：write&#x2F;send</p>
<p>5.关闭连接</p>
<p>​	close();</p>
</blockquote>
<h2 id="Web服务器项目"><a href="#Web服务器项目" class="headerlink" title="Web服务器项目"></a>Web服务器项目</h2><h3 id="阻塞-非阻塞、同步-异步-网络IO"><a href="#阻塞-非阻塞、同步-异步-网络IO" class="headerlink" title="阻塞&#x2F;非阻塞、同步&#x2F;异步(网络IO)"></a>阻塞&#x2F;非阻塞、同步&#x2F;异步(网络IO)</h3><blockquote>
<p>典型的一次IO的两个阶段：数据就绪和数据读写</p>
</blockquote>
<ul>
<li><p>数据就绪：根据系统IO操作的就绪状态</p>
<ul>
<li>阻塞<ul>
<li>会将线程挂起，挂起的线程不会占用CPU资源</li>
</ul>
</li>
<li>非阻塞<ul>
<li>若没有数据，不会挂起，立即返回函数值</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/ee6f0c882e0a420fb3152bddacd421bb.png" alt="image-20230917103911079"></p>
</li>
<li><p>数据读写：根据应用程序和内核的交互方式</p>
<ul>
<li>同步：缓冲区的内容<strong>自己搬</strong>到buf中，读取完之后才返回。这个过程阻塞，花的自己时间，编程简单</li>
<li>异步：效率高，编程复杂，缓冲区的内容<strong>操作系统搬</strong>到buf中</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/d4c9ca506a3648cda5a4181e4a528bc5.png" alt="image-20230917104652319"></p>
</li>
</ul>
<blockquote>
<p>在处理IO的时候，阻塞和非阻塞都是同步IO，只用使用了特殊的API才是异步IO</p>
</blockquote>
<blockquote>
<p>一个典型的网络IO接口调用，分为两个阶段，分别是“<strong>数据就绪”和“数据读写</strong>”，数据就绪阶段分为阻塞和非阻塞，表现的结构就是，<strong>阻塞当前线程或者是直接返回</strong></p>
<p>同步表示A向B请求调用一个网络IO接口时(或API)，<strong>数据的读写都是由请求方A自己来完成的</strong>(不管是阻塞还是非阻塞)；异步表示A向B请求调用一个网络IO<strong>，向B传入请求的事件以及事件发生的通知方式，A就可以处理其他逻辑了</strong>，当B监听到事件处理完成后，会用事先预定好的通知方式通知A处理结果</p>
</blockquote>
<ul>
<li>同步阻塞</li>
<li>同步非阻塞</li>
<li>异步阻塞</li>
<li>异步非阻塞</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/fd1e365ab737401db6d3914a5c9b6140.png" alt="image-20230917113854019"></p>
<h3 id="UNIX、Linux上的五种IO模型"><a href="#UNIX、Linux上的五种IO模型" class="headerlink" title="UNIX、Linux上的五种IO模型"></a>UNIX、Linux上的五种IO模型</h3><h4 id="阻塞blocking"><a href="#阻塞blocking" class="headerlink" title="阻塞blocking"></a>阻塞blocking</h4><ul>
<li><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回值，必须等待这个函数返回才能进行下一步动作</p>
<p><img src="https://img-blog.csdnimg.cn/30b2cc23aa934dcdaa0a8d0bbac7bdc2.png" alt="image-20230917122034693"></p>
</li>
<li><p>该模型效率太低，不友好</p>
</li>
</ul>
<h4 id="非阻塞non-bkocking-NIO"><a href="#非阻塞non-bkocking-NIO" class="headerlink" title="非阻塞non-bkocking(NIO)"></a>非阻塞non-bkocking(NIO)</h4><ul>
<li><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪，没有就绪就去做其他事情。非阻塞IO执行系统调用总是<strong>立即返回</strong>，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分两种情况，对于accept、revc和send，时间未发生时，errno通常被设置成<strong>EAGAIN</strong></p>
<p><img src="https://img-blog.csdnimg.cn/62461a8026c54c57b5087abd9a5c1d53.png" alt="image-20230917123018739"></p>
</li>
</ul>
<h4 id="IO复用IO-multiplexing"><a href="#IO复用IO-multiplexing" class="headerlink" title="IO复用IO multiplexing"></a>IO复用IO multiplexing</h4><ul>
<li>Linux用select、pol、epollAPI实现IO复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是<strong>这些函数可以同时阻塞多个IO操作</strong>。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数<ul>
<li>一次检测多个客户事件</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/08ba7ff75476497db9c056acb1643650.png" alt="image-20230917123912478"></p>
<h4 id="信号驱动-signal-driven"><a href="#信号驱动-signal-driven" class="headerlink" title="信号驱动 signal-driven"></a>信号驱动 signal-driven</h4><ul>
<li>Linux用套接口进行信号驱动，<strong>安装一个信号处理函数，进程继续运行并不阻塞</strong>，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/62f4209ce69c46f182e768a015e9260f.png" alt="image-20230917124432371"></p>
<ul>
<li><strong>内核在第一个阶段是异步的，在第二个阶段是同步的</strong></li>
<li>与非阻塞IO区别在于它提供了消息通知机制，不需要用户进程不断的轮训检查，减少了系统API的调用次数，提高了效率</li>
</ul>
<h4 id="异步-asynchoronous"><a href="#异步-asynchoronous" class="headerlink" title="异步 asynchoronous"></a>异步 asynchoronous</h4><ul>
<li><p>Linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序</p>
<ul>
<li><strong>使用较少</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/4853e0b637e3458c8d67190e777ed22a.png" alt="image-20230917124906786"></p>
</li>
</ul>
<h3 id="Web-Server-和Http"><a href="#Web-Server-和Http" class="headerlink" title="Web Server 和Http"></a>Web Server 和Http</h3><p><img src="https://img-blog.csdnimg.cn/194e85898dbc46bd8063f16762ed161d.png" alt="image-20230917153603724"></p>
<ul>
<li><p>Http是应用层协议</p>
<p><img src="https://img-blog.csdnimg.cn/450d6ba28e4f4c84bd4ac6503c03c040.png" alt="image-20230917154514268"></p>
<p><img src="https://img-blog.csdnimg.cn/637b5beb388d4434bf9a1210886a52fe.png" alt="image-20230917154635801"></p>
</li>
<li><p>过程</p>
<p><img src="https://img-blog.csdnimg.cn/96977d5d46da4d87b45777d749a4a66a.png" alt="image-20230917155537962"></p>
</li>
<li><p>http协议是基于TCP&#x2F;IP协议之上的应用层协议，基于请求-响应的模式。HTTP协议规定，<strong>请求从客户端发出，最后服务器端响应请求并返回。</strong></p>
</li>
</ul>
<h4 id="HTTP格式"><a href="#HTTP格式" class="headerlink" title="HTTP格式"></a>HTTP格式</h4><ul>
<li><p>请求报文格式</p>
<p><img src="https://img-blog.csdnimg.cn/c8976358804043809a55c450241b69f2.png" alt="image-20230917160108259"></p>
<p><img src="https://img-blog.csdnimg.cn/ca8d0f40494e45a2bc01c083ce53fe23.png" alt="image-20230917160519649"></p>
</li>
<li><p>响应报文请求格式</p>
<p><img src="https://img-blog.csdnimg.cn/a87395ff444e48e79a9708864c1a25c6.png" alt="image-20230917160137415"></p>
</li>
</ul>
<h3 id="服务器编程基本框架"><a href="#服务器编程基本框架" class="headerlink" title="服务器编程基本框架"></a>服务器编程基本框架</h3><blockquote>
<p>虽然服务器程序种类繁多，但基本框架都一样，不同指出在于逻辑处理</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/530573c46bbc4a67986c0a22e2fb61bc.png" alt="image-20230917204550350"></p>
<ul>
<li><strong>IO处理单元</strong>是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接受客户数据，将服务器响应数据返回给客户端。但数据的收发不一定在IO处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式</li>
<li><strong>逻辑单元</strong>通常是一个进程或线程，它分析并处理客户数据，然后将结果<strong>传递给IO处理单元或直接发送给客户</strong>端(取决于事件处理模式)。服务器通常拥有多个逻辑单元，以实现对多个客户的任务的并发处理 </li>
<li><strong>网络存储单元</strong>可以是数据库、缓存和文件，但不是必须的</li>
<li><strong>请求队列</strong>是<strong>各单元之间的通信方式的抽象</strong>。IO处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件，<strong>请求队列通常被实现为池的一部分</strong></li>
</ul>
<h4 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h4><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26943938">(7 封私信 &#x2F; 80 条消息) 如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)</a></p>
<blockquote>
<p>服务器程序通常需要处理三类事件：<strong>IO事件</strong>、<strong>信号</strong>及<strong>定时事件</strong></p>
<p>两种高效的事件处理模式：Reactor和Proactor，<strong>同步IO模型通常用于实现Reactor</strong>模式，异步IO模型通常用于实现<strong>Proactor</strong>模式</p>
</blockquote>
<h5 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h5><ul>
<li><p>要求主线程(I&#x2F;O处理单元)<strong>只负责监听文件描述符上是否有事件发生</strong>，有的话立即将该事件通知工作线程(逻辑单元，子线程)，<strong>将socket可读可写事件放入请求队列</strong>，交给<strong>工作线程处理</strong>。除此之外，主线程不做任何其他实质性的工作。<strong>读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</strong></p>
</li>
<li><p><strong>是非阻塞同步网络模式</strong></p>
</li>
<li><p>使用同步I&#x2F;O(以epoll_wait为例)实现Reactor模式的工作流程是：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的<strong>读就绪事件</strong></li>
<li>主线程调用epoll_wait等待socket上有数据<strong>可读</strong></li>
<li>当socket上有数据可读时，<strong>epoll_wait通知主线程。</strong>主线程则将socket可读事件放入请求队列</li>
<li>睡眠在请求队列的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>当主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户的请求结果</li>
</ol>
</li>
</ul>
<p>​		<img src="https://img-blog.csdnimg.cn/41b2cd4b8a4f4d4c8aa969cb50d98c28.png" alt="image-20230917212906493"></p>
<blockquote>
<p> Reactor 模式主要由Reactor和处理资源池这两个核心部分组成。</p>
<ul>
<li>Reactor 负责<strong>监听和分发事件</strong>，事件类型包含<strong>连接事件、读写事件</strong>；</li>
<li><strong>处理资源池负责处理事件</strong>，如 read -&gt; 业务逻辑 -&gt; send；</li>
</ul>
<p> Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：</p>
<ul>
<li>Reactor 的数量可以只有一个，也可以有多个；</li>
<li>处理资源池可以是单个进程 &#x2F; 线程，也可以是多个进程 &#x2F;线程；</li>
</ul>
<p> Reactor<strong>是非阻塞同步网络</strong>。事件由操<strong>作系统通知应用进程，进程处理</strong></p>
</blockquote>
<h5 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h5><ul>
<li><strong>工作线程仅仅负责业务逻辑。不负责读写</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/d40557a1dfb445128332eda17be530c3.png" alt="image-20230917212937097"></p>
<ul>
<li><p>工作流程</p>
<p><img src="https://img-blog.csdnimg.cn/5ac3e7be3f1b4361a4e9c0359abd82e6.png" alt="image-20230917213358873"></p>
</li>
<li><p><strong>同步IO工作流程</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/f092018a05384c9c95a74a73637a3b0d.png" alt="image-20230917220658798"></p>
<p>​	<img src="https://img-blog.csdnimg.cn/890a9d3fda2d4b03963c76bd0470dc19.png" alt="image-20230917220754510"></p>
<p>因此，<strong>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong>，<strong>而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</strong>。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I&#x2F;O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p>
<p>举个实际生活中的例子，Reactor 模式就是快递员在楼下，给你打电话告诉你快递到你家小区了，你需要自己下楼来拿快递。而在 Proactor 模式下，快递员直接将快递送到你家门口，然后通知你</p>
<blockquote>
<p><strong>Proactor是异步网络模式</strong>，感知的是已经完成的读写事件。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的<strong>读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据</strong>，操作系统完成读写工作后，就会通知应用进程直接处理数据。</p>
<p><strong>事件由操作系统处理，处理完成后通知应用进程</strong></p>
</blockquote>
<hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li><p>线程池是由服务器预先创建的一组子线程，<strong>线程池中的线程号数量应该和CPU数量差不多</strong>。线程池中所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。</p>
<ul>
<li>比动态创建子线程开销小得多</li>
</ul>
</li>
<li><p>如何选择子线程？</p>
<ul>
<li>随机算法、轮流选取(Round Robinsuanfa </li>
<li>主线程和所有子线程通过一个<strong>共享队列</strong>来同步，子线程都睡眠在该工作队列上，当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，<strong>只有一个子线程将获得新任务的接管权</strong>，它可以从工作队列中取出任务并执行，其他子线程将继续睡眠在工作队列上</li>
</ul>
</li>
<li><p>一般模型</p>
<p><img src="https://img-blog.csdnimg.cn/17bec44df0544105a94373cb450078bd.png" alt="image-20230918213759953"></p>
</li>
<li><p>几个概念</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>空间换时间：浪费服务器的硬件资源，换取运行效率</p>
</li>
<li><p>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源</p>
</li>
<li><p>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配</p>
</li>
<li><p>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源</p>
</li>
</ul>
</blockquote>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">jingxiaoyang</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://yangjx29.github.io/posts/f6491cfb.html">https://yangjx29.github.io/posts/f6491cfb.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">jingxiaoyang</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'Ov23liIM5S2VDoNlIHcI',
        clientSecret: 'd317e52266d8a27cc292d6bd87d8579175675baa',
        repo: 'gitalk',
        owner: 'yangjx29',
        admin: "yangjx29",
        id: '2024-08-08T10-08-22',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/e255a10a.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="计算机网络">
                        
                        <span class="card-title">计算机网络</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-08-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AF%BE%E5%86%85%E8%B5%84%E6%96%99/" class="post-category">
                                    课内资料
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/bf6d62af.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="毛概">
                        
                        <span class="card-title">毛概</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-08-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AF%BE%E5%86%85%E8%B5%84%E6%96%99/" class="post-category">
                                    课内资料
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

            

                <div class="container row center-align"
                    style="margin-bottom: 15px !important;">
                    <div class="col s12 m8 l8 copy-right">
                        Copyright&nbsp;&copy;
                        
                            <span id="year">2023-2024</span>
                            
                                    <a href="/about" target="_blank">jingxiaoyang</a>
                                    |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
                                    |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery"
                                        target="_blank">Matery</a>
                                    
                                            <br>
                                            
                                                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">
                                                        285.2k
                                                    </span>
                                                    
                                                        
                                                            
                                                                
                                                                    
                                                                        
                                                                            <span id="busuanzi_container_site_pv">
                                                                                &nbsp;|&nbsp;<i
                                                                                    class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                                                                                    <span id="busuanzi_value_site_pv"
                                                                                        class="white-color"></span>
                                                                            </span>
                                                                            
                                                                                
                                                                                    <span
                                                                                        id="busuanzi_container_site_uv">
                                                                                        &nbsp;|&nbsp;<i
                                                                                            class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                                                                                            <span
                                                                                                id="busuanzi_value_site_uv"
                                                                                                class="white-color"></span>
                                                                                    </span>
                                                                                    
                                                                                        <br>

                                                                                        <!-- 运行天数提醒. -->
                                                                                        
                                                                                            <span id="sitetime"> Loading
                                                                                                ...</span>
                                                                                            <script>
                                                                                                var calcSiteTime = function () {
                                                                                                    var seconds = 1000;
                                                                                                    var minutes = seconds * 60;
                                                                                                    var hours = minutes * 60;
                                                                                                    var days = hours * 24;
                                                                                                    var years = days * 365;
                                                                                                    var today = new Date();
                                                                                                    var startYear = "2023";
                                                                                                    var startMonth = "4";
                                                                                                    var startDate = "29";
                                                                                                    var startHour = "0";
                                                                                                    var startMinute = "0";
                                                                                                    var startSecond = "0";
                                                                                                    var todayYear = today.getFullYear();
                                                                                                    var todayMonth = today.getMonth() + 1;
                                                                                                    var todayDate = today.getDate();
                                                                                                    var todayHour = today.getHours();
                                                                                                    var todayMinute = today.getMinutes();
                                                                                                    var todaySecond = today.getSeconds();
                                                                                                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                                                                                                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                                                                                                    var diff = t2 - t1;
                                                                                                    var diffYears = Math.floor(diff / years);
                                                                                                    var diffDays = Math.floor((diff / days) - diffYears * 365);

                                                                                                    // 区分是否有年份.
                                                                                                    var language = 'zh-CN';
                                                                                                    if (startYear === String(todayYear)) {
                                                                                                        document.getElementById("year").innerHTML = todayYear;
                                                                                                        var daysTip = 'This site has been running for ' + diffDays + ' days';
                                                                                                        if (language === 'zh-CN') {
                                                                                                            daysTip = '已经在一起 ' + diffDays + ' 天';
                                                                                                        } else if (language === 'zh-HK') {
                                                                                                            daysTip = '本站已運行 ' + diffDays + ' 天';
                                                                                                        }
                                                                                                        document.getElementById("sitetime").innerHTML = daysTip;
                                                                                                    } else {
                                                                                                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                                                                                                        var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                                                                                            + diffDays + ' days';
                                                                                                        if (language === 'zh-CN') {
                                                                                                            yearsAndDaysTip = '已经在一起 ' + diffYears + ' 年 ' + diffDays + ' 天';
                                                                                                        } else if (language === 'zh-HK') {
                                                                                                            yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                                                                                                        }
                                                                                                        document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                                                                                                    }
                                                                                                }

                                                                                                calcSiteTime();
                                                                                            </script>
                                                                                            
                                                                                                <br>
                                                                                                
                    </div>
                    <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/yangjx29" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2372256530@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2372256530" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2372256530" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>








                    </div>
                </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: ""
        });
        daovoice('update');
    </script>
    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
